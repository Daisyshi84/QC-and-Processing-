---
output: 
  html_document: 
    toc: yes
header-includes:
  \usepackage{booktabs}
params:
  jurisdiction: "Michigan"
  juris: "MI"
  template: "Redcap"
  update_month: "January 2023"
  submission_date: "20230106"
  upload_folder: "2023.01"
  month_folder: "2023.01"
  case_end_date: "December 24, 2022"
  death_end_date: "December 3, 2022"
  mmwr_wk_cases_end: "202251"
  mmwr_wk_deaths_end: "202248"
---

```{r setup, include=FALSE, echo=FALSE}

knitr::opts_chunk$set(echo = FALSE, include = FALSE) # sets defaults to always hide the code (echo) and to not include the output resulting from the code (include)

require(tidyverse)
require(lubridate)
require(readxl)
require(xlsx)
library(data.table)
library(kableExtra)

### Changes in this file:

### Set a few vars to populate the QC report header from the params set in the YAML
### Note these can also be used directly from the params, but assigning to variables here to keep in line with original formatting and make it easier to reference them
jurisdiction <- params$jurisdiction
juris <- params$juris
update_month <- params$update_month
date <- Sys.Date()

```

---
title: "`r update_month` Processing of `r jurisdiction` Data"
author: "Avnika B. Amin; adapted by Lauren Linde"
date: "`r Sys.Date()`"
--- 


# Overview

The purpose of this code is to assign vaccination status at time of positive test and to identify vaccine product of primary series for COVID-19 cases pulled from the Case Only - Epi Task Force (COETF) dataset. Generally, case data are downloaded the first Friday of every month for participating jurisdictions.  

# New Changes


```{r read_data, include=FALSE}

### first, make sure to update all of these path references as appropriate
path_to_relative <- "C:/Users/ypc8/OneDrive - CDC/General/"
data_path <- paste0(path_to_relative, "Breakthrough surveillance data/Option 2 LL+Agg Datasets/Uploaded Data/", params$upload_folder, "/Linelists/") # path to the downloaded line lists
linelist_output_path <- paste0(path_to_relative, "Breakthrough surveillance data/Option 2 LL+Agg Datasets/Output Linelist Datasets/", params$month_folder,"/") # path for saving the master linelist output file
aggregate_output_path <- paste0(path_to_relative, "Breakthrough surveillance data/Option 2 LL+Agg Datasets/Output Aggregate Datasets/", params$month_folder,"/") # path for saving each jurisdiction's aggregated file
qc_output_path <- paste0(path_to_relative, "Breakthrough surveillance data/Option 2 LL+Agg Datasets/IDs for QC/", params$month_folder, "/") # path for saving the case IDs needing further QC from the jurisdictions
surv_start_date <- mdy("October 3, 2021") # this is the start date for vaccine impact surveillance in general; do not update unless specifically indicated
agg_start_date <- mdy("April 4, 2021") # this is the start date for the vaccine impact website; do not update unless specifically indicated
case_end_date <- mdy(params$case_end_date) # this is the latest date for case reporting; set based on the params
death_end_date <- mdy(params$death_end_date) # this is the latest date for death reporting; set based on the params
boosterAuthDate <- mdy(08132021) # current date used for the earliest a "valid" booster dose could be administered; change if definition updated
# reference for indicator date that something isn't accounted for in code to fix skipped entries
checkDate <- mdy(01011800)
freeze_date <- mdy("December 26, 2021") # this is the start date for including new data for jurisdictions that are freezing their historical data
freeze_data_path<-paste0(path_to_relative,"Breakthrough surveillance data/Option 2 LL+Agg Datasets/Output Linelist Datasets/Data freeze files thru 202151/")

### functions 
naCheck <- function(x) {  table(is.na(x)) } # function to check for missing values
excelDates <- function(x) { as.Date(as.numeric(x), origin = as.Date("1899-12-30", format = "%Y-%m-%d")) } # function to convert dates if origin file is XLS or XLSX instead of CSV

## Step 1: Read in data ********************************************************** 
## Suggest reading all variables in as text to avoid R imposing incorrect formatting on variables (due to variation in jurisdictions' provided data)
## Make sure to add indicator variable for reporting jurisdiction with each import
## Also convert all variable names to lowercase - R is case-sensitive
## Slight differences in how the "Other race" variable is named in REDCap template; check which states need renaming
## Jurisdiction-specific handling of variables needs to be checked and redone as necessary every month

# import data; there should be one file per jurisdiction each month
### get all file paths; imperative that ONLY the files intended for processing are in the folder referenced by data_path
#files <- list.files(path = data_path, all.files = F, full.names = T)
files <- list.files(path = data_path, all.files = F, full.names = F)

# LRL UPDATE: read in data files based on the param for juris set in the YAML, including some specific formatting for certain jurisdictions that will be updated as needed, and adding an indicator variable for which jurisdiction is reporting
# make sure that the variable names used by a jurisdiction match the names/values that are supposed to be used for the template they've chosen (REDCAP or DCIPHER)

if(params$juris=="AZ"){
  upload_data <- fread(paste0(data_path,files[substr(files,1,2)=="AZ"]), colClasses = "character",na.strings=c(".","")) %>% mutate(juris = "AZ")}

if(params$juris=="AR"){
  upload_data <- read_xlsx(paste0(data_path,files[substr(files,1,2)=="AR"]), col_types = "text") %>% mutate(juris = "AR") %>% rename(race___oth = race___other)}

if(params$juris=="CO"){
  upload_data <- fread(paste0(data_path,files[substr(files,1,2)=="CO"]), colClasses = "character",na.strings=c(".","")) %>% mutate(juris = "CO")}  #rename(race___oth = race___other, dob = BirthDate)

if(params$juris=="CT"){
  upload_data <- fread(paste0(data_path,files[substr(files,1,2)=="CT"]), colClasses = "character",na.strings=c(".","")) %>% mutate(juris = "CT")}

if(params$juris=="DC"){
  upload_data <- read_xlsx(paste0(data_path,files[substr(files,1,2)=="DC"]), col_types = "text") %>% mutate(juris = "DC")
  
  # do a quick fix for their excel dates that read in incorrectly: some are reading in as a blank space character R cannot recognize, but those are
  # character variables with length 1 whereas the date should read in as a 5 digit number. So, anything with length 1 can be replaced by NA
  upload_data$vaxdate1[nchar(upload_data$vaxdate1)==1]<-NA
  upload_data$vaxdate2[nchar(upload_data$vaxdate2)==1]<-NA
  upload_data$vaxdate3[nchar(upload_data$vaxdate3)==1]<-NA
  upload_data$vaxdate4[nchar(upload_data$vaxdate4)==1]<-NA
  upload_data$vaxmfr2[nchar(upload_data$vaxmfr2)==1]<-NA
  upload_data$vaxmfr3[nchar(upload_data$vaxmfr3)==1]<-NA
  upload_data$vaxmfr4[nchar(upload_data$vaxmfr4)==1]<-NA
  }

if(params$juris=="FL"){
  upload_data <- fread(paste0(data_path,files[substr(files,1,2)=="FL"]), colClasses = "character",na.strings=c(".","","NA")) %>% mutate(juris = "FL") 
  
  # didn't totally work the first time...
  upload_data[upload_data==""]<-NA
  }


# if(params$juris=="GA"){
#   upload_data <- read_csv(paste0(data_path,files[substr(files,1,2)=="GA"]), col_types = cols(.default = "c")) %>% mutate(juris = "GA") %>% rename(race___oth = race___other)}

if(params$juris=="GA"){
  upload_data <- read_xlsx(paste0(data_path,files[substr(files,1,2)=="GA"]), col_types = "text") %>% mutate(juris = "GA") #%>% rename(race___oth = race___other)
  }

if(params$juris=="KS"){
  upload_data <- read_xlsx(paste0(data_path,files[substr(files,1,2)=="KS"]), col_types = "text") %>% mutate(juris = "KS")}

if(params$juris=="MA"){
  upload_data <- fread(paste0(data_path,files[substr(files,1,2)=="MA"]), colClasses = "character",na.strings=c(".","")) %>% mutate(juris = "MA")}

if(params$juris=="MI"){
  upload_data <- fread(paste0(data_path,files[substr(files,1,2)=="MI"]), colClasses = "character",na.strings=c(".","")) %>% mutate(juris = "MI") #%>% rename(race___oth = race___other)
  }

if(params$juris=="NC"){
  upload_data <- fread(paste0(data_path,files[substr(files,1,2)=="NC"]), colClasses = "character",na.strings=c(".","")) %>% 
    mutate(juris = "NC") %>%
    rename(vaxmfr1 = d1_mfr, vaxmfr2 = d2_mfr, vaxmfr3 = d3_mfr, vaxmfr4 = d4_mfr, vaxmfr5 = d5_mfr, vaxmfr6 = d6_mfr,
           vaxdate1=vrvac_covid19_dt1,vaxdate2=vrvac_covid19_dt2,vaxdate3=vrvac_covid19_dt3,vaxdate4=vrvac_covid19_dt4,vaxdate5=vrvac_covid19_dt5,vaxdate6=vrvac_covid19_dt6,
           vaxtype1 = d1_cvx, vaxtype2 = d2_cvx, vaxtype3 = d3_cvx, vaxtype4 = d4_cvx, vaxtype5 = d5_cvx, vaxtype6=d6_cvx,
           death_yn = died, pos_spec_dt=covtestdt,
           race_asian=race___asi,race_aian=race___ami, race_black=race___bla, race_nhpi=race___haw, race_white=race___whi, race_other=race___other, race_unk=race___unk)
  }

if(params$juris=="NE"){
  upload_data <- fread(paste0(data_path,files[substr(files,1,2)=="NE"]), colClasses = "character",na.strings=c(".","")) %>% mutate(juris = "NE") %>% rename(race___oth = race___other)}

if(params$juris=="NJ"){
  upload_data <- read_xlsx(paste0(data_path,files[substr(files,1,2)=="NJ"]), col_types = "text") %>% mutate(juris = "NJ")}

if(params$juris=="NM"){
  upload_data <- fread(paste0(data_path,files[substr(files,1,2)=="NM"]), colClasses = "character",na.strings=c(".","")) %>% mutate(juris = "NM")}

if(params$juris=="RI"){
  upload_data <- fread(paste0(data_path,files[substr(files,1,2)=="RI"]), colClasses = "character",na.strings=c(".",""," ")) %>% mutate(juris = "RI")}

if(params$juris=="WI"){
  upload_data <- fread(paste0(data_path,files[substr(files,1,2)=="WI"]), colClasses = "character",na.strings=c(".","")) %>% mutate(juris = "WI") %>% rename(race___oth = race___other)}

# set all column names lowercase, as formatting varies
names(upload_data) <- tolower(names(upload_data))

# set upload data as a data.frame explicitly (since fread reads in as a data.table object, which has different properties)
upload_data <- as.data.frame(upload_data)

# LRL note: could add a basic check here for if the submitted column names match the variable names we are expecting to receive for each jurisdiction?
```

```{r special_NC_biv}
# include a special section for NC to include their bivalent doses as one of the regular doses 1-6

if(params$juris=="NC"){
# make a column to track if the bivalent doses get assigned appropriately
upload_data<-upload_data %>%
  mutate(assigned_biv=case_when(is.na(vrvac_covid19_dtbival) ~ NA_real_,
                                T ~ 0))


  for(i in 1:nrow(upload_data)){
    # if the biv date is not NA, then check where it belongs in the dose sequence
    if(is.na(upload_data$vrvac_covid19_dtbival[i])==F){
      # if the biv date is after the last vax date, then determine which dose corresponds to the last vaxdate and slot biv date after that dose
      if(as.Date(upload_data$vrvac_covid19_dtbival[i],"%m/%d/%Y") > as.Date(upload_data$lastvaxdt[i],"%m/%d/%Y")){
        # Last dose is dose 1, assign biv to dose 2:
        if(is.na(upload_data$vaxdate1[i])==F & upload_data$lastvaxdt[i]==upload_data$vaxdate1[i] & is.na(upload_data$vaxdate2[i])){
          upload_data$vaxdate2[i]<-upload_data$vrvac_covid19_dtbival[i]
          upload_data$vaxmfr2[i]<-upload_data$fb22_mfr[i]
          upload_data$vaxtype2[i]<-upload_data$fb22_cvx[i]
          upload_data$assigned_biv[i]<-2
        } else if(is.na(upload_data$vaxdate2[i])==F & upload_data$lastvaxdt[i]==upload_data$vaxdate2[i] & is.na(upload_data$vaxdate3[i])){
        # Last dose is dose 2, assign biv to dose 3:
          upload_data$vaxdate3[i]<-upload_data$vrvac_covid19_dtbival[i]
          upload_data$vaxmfr3[i]<-upload_data$fb22_mfr[i]
          upload_data$vaxtype3[i]<-upload_data$fb22_cvx[i]
          upload_data$assigned_biv[i]<-3
        } else if(is.na(upload_data$vaxdate3[i])==F & upload_data$lastvaxdt[i]==upload_data$vaxdate3[i] & is.na(upload_data$vaxdate4[i])){
        # Last dose is dose 3, assign biv to dose 4:
          upload_data$vaxdate4[i]<-upload_data$vrvac_covid19_dtbival[i]
          upload_data$vaxmfr4[i]<-upload_data$fb22_mfr[i]
          upload_data$vaxtype4[i]<-upload_data$fb22_cvx[i]
          upload_data$assigned_biv[i]<-4
        } else if(is.na(upload_data$vaxdate4[i])==F & upload_data$lastvaxdt[i]==upload_data$vaxdate4[i] & is.na(upload_data$vaxdate5[i])){
        # Last dose is dose 4, assign biv to dose 5:
          upload_data$vaxdate5[i]<-upload_data$vrvac_covid19_dtbival[i]
          upload_data$vaxmfr5[i]<-upload_data$fb22_mfr[i]
          upload_data$vaxtype5[i]<-upload_data$fb22_cvx[i]
          upload_data$assigned_biv[i]<-5
        } else if(is.na(upload_data$vaxdate5[i])==F & upload_data$lastvaxdt[i]==upload_data$vaxdate5[i] & is.na(upload_data$vaxdate6[i])){
        # Last dose is dose 5, assign biv to dose 6:
          upload_data$vaxdate6[i]<-upload_data$vrvac_covid19_dtbival[i]
          upload_data$vaxmfr6[i]<-upload_data$fb22_mfr[i]
          upload_data$vaxtype6[i]<-upload_data$fb22_cvx[i]
          upload_data$assigned_biv[i]<-6} else{
            upload_data$assigned_biv[i]<-0
          }
      }
    }
  }


# There were only 49 that didn't get assigned this way - of those, the vast majority seem to have out of order vax dates somewhere in the dose sequence and would be excluded regardless. There were a few (5) where the last vax date was actually the bivalent dose and the person had that dose recorded as a non-bivalent dose, so we could potentially overwrite the dose with the bivalent CVX code? Otherwise doesn't seem worth changing anything

# fix a couple of NC date issues in vaxdate6 by hand...
upload_data$vaxdate6[upload_data$vaxdate6=="11-Apr-22"]<-"4/11/2022"
upload_data$vaxdate6[upload_data$vaxdate6=="11-Aug-22"]<-"8/11/2022"
upload_data$vaxdate6[upload_data$vaxdate6=="12-Apr-22"]<-"4/12/2022"
upload_data$vaxdate6[upload_data$vaxdate6=="13-Sep-22"]<-"9/13/2022"
upload_data$vaxdate6[upload_data$vaxdate6=="18-Apr-22"]<-"4/18/2022"
upload_data$vaxdate6[upload_data$vaxdate6=="22-Sep-22"]<-"9/22/2022"
upload_data$vaxdate6[upload_data$vaxdate6=="25-Mar-21"]<-"3/25/2021"
upload_data$vaxdate6[upload_data$vaxdate6=="29-Apr-22"]<-"4/29/2022"
}

# write out the data so I don't have to run this part again this month
#write.csv(upload_data,paste0(data_path,"NC corrected biv data.csv"))





```


```{r dcipher, include=T}
# converting dcipher template to redcap format; only needs to happen if the jurisdiction being processed uses the DCIPHER template
# purpose isn't to extensively recode variables, but only do enough to be consistent with the REDCAP template

# LRL update: wrap dcipher section in an if statement, so no need to comment out anything

if(params$template=="DCIPHER"){
  
# LRL update: move up some code that was originally under Check 1 - add in missing columns for doses 3/4/5 for the dcipher jurisdictions (will check/add for redcap below)
# do this before the DCIPHER processing section below so that we can run one version of that code and not have to adapt for states missing those variables
# add in other missing vars as well (mainly for NC?)
  if(!("vaxdate3" %in% names(upload_data))){upload_data$vaxdate3 <- NA
                                            print("vaxdate3 missing")}
  if(!("vaxdate4" %in% names(upload_data))){upload_data$vaxdate4 <- NA
                                            print("vaxdate4 missing")}
  if(!("vaxdate5" %in% names(upload_data))){upload_data$vaxdate5 <- NA
                                            print("vaxdate5 missing")}
  if(!("vaxdate6" %in% names(upload_data))){upload_data$vaxdate6 <- NA
                                            print("vaxdate6 missing")}
  if(!("vaxmfr3" %in% names(upload_data))){upload_data$vaxmfr3 <- NA_character_
                                            print("vaxmfr3 is missing")}
  if(!("vaxmfr4" %in% names(upload_data))){upload_data$vaxmfr4 <- NA_character_
                                            print("vaxmfr4 is missing")}
  if(!("vaxmfr5" %in% names(upload_data))){upload_data$vaxmfr5 <- NA_character_
                                            print("vaxmfr5 is missing")}
  if(!("vaxmfr6" %in% names(upload_data))){upload_data$vaxmfr6 <- NA_character_
                                            print("vaxmfr6 is missing")}
  if(!("vaxtype6" %in% names(upload_data))){upload_data$vaxtype6 <- NA_character_
                                            print("vaxtype6 is missing")}
  if(!("race_aian" %in% names(upload_data))){upload_data$race_aian <- NA_character_
                                            print("race_aian is missing")}
  if(!("race_asian" %in% names(upload_data))){upload_data$race_asian <- NA_character_
                                            print("race_asian is missing")}
  if(!("race_black" %in% names(upload_data))){upload_data$race_black <- NA_character_
                                            print("race_black is missing")}
  if(!("race_nhpi" %in% names(upload_data))){upload_data$race_nhpi <- NA_character_
                                            print("race_nhpi is missing")}
  if(!("race_white" %in% names(upload_data))){upload_data$race_white <- NA_character_
                                            print("race_white is missing")}
  if(!("race_unk" %in% names(upload_data))){upload_data$race_unk <- NA_character_
                                            print("race_unk is missing")}
  if(!("race_other" %in% names(upload_data))){upload_data$race_other <- NA_character_
                                            print("race_other is missing")}
  if(!("test_pcr" %in% names(upload_data))){upload_data$test_pcr <- NA
                                            print("test_pcr is missing")}
  if(!("test_other" %in% names(upload_data))){upload_data$test_other <- NA
                                            print("test_other is missing")}
  if(!("sympstatus" %in% names(upload_data))){upload_data$sympstatus <- NA
                                            print("sympstatus is missing")}
  if(!("hosp_yn" %in% names(upload_data))){upload_data$hosp_yn <- NA
                                            print("hosp_yn is missing")}
  if(!("test_other_spec" %in% names(upload_data))){upload_data$test_other_spec <- NA
                                            print("test_other_spec is missing")}
  
  # add a simple check on submitted vaxmfr values to make sure we catch any typos or anything new:
  if(sum(unique(upload_data$vaxmfr1) %in% c("Janssen","JSN","Johnson and Johnson","Pfizer","PFR","PFIZER","Moderna","MOD","MODERNA","Unknown manufacturer","Unknown","AstraZeneca","AstraZen","NVX","Novavax")) < length(unique(upload_data$vaxmfr1[is.na(upload_data$vaxmfr1)==F]))){
    print("Check vaxmfr1 values")}
  if(sum(unique(upload_data$vaxmfr2) %in% c("Janssen","JSN","Johnson and Johnson","Pfizer","PFR","PFIZER","Moderna","MOD","MODERNA","Unknown manufacturer","Unknown","AstraZeneca","AstraZen","NVX","Novavax")) < length(unique(upload_data$vaxmfr2[is.na(upload_data$vaxmfr2)==F]))){
    print("Check vaxmfr2 values")}
  if(sum(unique(upload_data$vaxmfr3) %in% c("Janssen","JSN","Johnson and Johnson","Pfizer","PFR","PFIZER","Moderna","MOD","MODERNA","Unknown manufacturer","Unknown","AstraZeneca","AstraZen","NVX","Novavax")) < length(unique(upload_data$vaxmfr3[is.na(upload_data$vaxmfr3)==F]))){
    print("Check vaxmfr3 values")}
  if(sum(unique(upload_data$vaxmfr4) %in% c("Janssen","JSN","Johnson and Johnson","Pfizer","PFR","PFIZER","Moderna","MOD","MODERNA","Unknown manufacturer","Unknown","AstraZeneca","AstraZen","NVX","Novavax")) < length(unique(upload_data$vaxmfr4[is.na(upload_data$vaxmfr4)==F]))){
    print("Check vaxmfr4 values")}
  if(sum(unique(upload_data$vaxmfr5) %in% c("Janssen","JSN","Johnson and Johnson","Pfizer","PFR","PFIZER","Moderna","MOD","MODERNA","Unknown manufacturer","Unknown","AstraZeneca","AstraZen","NVX","Novavax")) < length(unique(upload_data$vaxmfr5[is.na(upload_data$vaxmfr5)==F]))){
    print("Check vaxmfr5 values")}
  if(sum(unique(upload_data$vaxmfr6) %in% c("Janssen","JSN","Johnson and Johnson","Pfizer","PFR","PFIZER","Moderna","MOD","MODERNA","Unknown manufacturer","Unknown","AstraZeneca","AstraZen","NVX","Novavax")) < length(unique(upload_data$vaxmfr6[is.na(upload_data$vaxmfr6)==F]))){
    print("Check vaxmfr6 values")}
  
dcipher <- upload_data %>%
  select(local_id, age, dob, sex, res_state, race_aian, race_asian, race_black, race_nhpi, race_white, race_unk, race_other, ethnicity, covtestdt = pos_spec_dt, vrvac_covid19_dt1 = vaxdate1, vaxmfr1, vrvac_covid19_type1=vaxtype1, vrvac_covid19_dt2 = vaxdate2, vaxmfr2, vrvac_covid19_type2=vaxtype2, vrvac_covid19_dt3 = vaxdate3, vaxmfr3, vrvac_covid19_type3=vaxtype3, vrvac_covid19_dt4 = vaxdate4, vaxmfr4, vrvac_covid19_type4=vaxtype4, vrvac_covid19_dt5 = vaxdate5, vaxmfr5, vrvac_covid19_type5=vaxtype5, vrvac_covid19_dt6 = vaxdate6, vaxmfr6, vrvac_covid19_type6=vaxtype6, symp_status = sympstatus, hosp_yn,death_yn, test_pcr, test_other, test_other_spec,juris) %>% # res_county
  # values for this conversion identified with lapply(dcipher$varname, unique) 
  # casestatus not present
  mutate(race___ami = if_else(is.na(race_aian),NA_character_,ifelse(race_aian == "No", "0", "1")),
         race___asi = if_else(is.na(race_asian),NA_character_,ifelse(race_asian == "No", "0", "1")),
         race___bla = if_else(is.na(race_black),NA_character_,ifelse(race_black == "No", "0", "1")),
         race___haw = if_else(is.na(race_nhpi),NA_character_,ifelse(race_nhpi == "No", "0", "1")),
         race___whi = if_else(is.na(race_white),NA_character_,ifelse(race_white == "No", "0", "1")),
         race___unk = if_else(is.na(race_unk),NA_character_,ifelse(race_unk == "No", "0", "1")),
         race___oth = if_else(is.na(race_other),NA_character_,ifelse(race_other == "No", "0", "1")),
         vrvac_covid19_man1 = case_when(
           vaxmfr1 %in% c("Pfizer", "PFR","PFIZER") ~ "1",
           vaxmfr1 %in% c("Moderna","MOD","MODERNA") ~ "2",
           vaxmfr1 %in% c("Janssen","JSN","Johnson and Johnson") ~ "4",
           vaxmfr1 %in% c("Unknown manufacturer", "Unknown") ~ "9",
           vaxmfr1 %in% c("AstraZeneca","AstraZen") ~ "5",
           vaxmfr1 %in% c("NVX","Novavax") ~ "6",
           vaxmfr1 %in% c("1", "2", "3", "4", "5", "9","6") ~ vaxmfr1,
           is.na(vaxmfr1) ~ NA_character_),
         vrvac_covid19_man2 = case_when(
           vaxmfr2 %in% c("Pfizer", "PFR","PFIZER") ~ "1",
           vaxmfr2 %in% c("Moderna","MOD","MODERNA") ~ "2",
           vaxmfr2 %in% c("Janssen","JSN","Johnson and Johnson") ~ "4",
           vaxmfr2 %in% c("Unknown manufacturer", "Unknown") ~ "9",
           vaxmfr2 %in% c("AstraZeneca","AstraZen") ~ "5",
           vaxmfr2 %in% c("NVX","Novavax") ~ "6",
           vaxmfr2 %in% c("1", "2", "3", "4", "5", "9","6") ~ vaxmfr2,
           is.na(vaxmfr2) ~ NA_character_),
          vrvac_covid19_man3 = case_when(
           vaxmfr3 %in% c("Pfizer", "PFR","PFIZER") ~ "1",
           vaxmfr3 %in% c("Moderna","MOD","MODERNA") ~ "2",
           vaxmfr3 %in% c("Janssen","JSN","Johnson and Johnson") ~ "4",
           vaxmfr3 %in% c("Unknown manufacturer", "Unknown") ~ "9",
           vaxmfr3 %in% c("AstraZeneca","AstraZen") ~ "5",
           vaxmfr3 %in% c("NVX","Novavax") ~ "6",
           vaxmfr3 %in% c("1", "2", "3", "4", "5", "9","6") ~ vaxmfr3,
           is.na(vaxmfr3) ~ NA_character_),
          vrvac_covid19_man4 = case_when(
           vaxmfr4 %in% c("Pfizer", "PFR","PFIZER") ~ "1",
           vaxmfr4 %in% c("Moderna","MOD","MODERNA") ~ "2",
           vaxmfr4 %in% c("Janssen","JSN","Johnson and Johnson") ~ "4",
           vaxmfr4 %in% c("Unknown manufacturer", "Unknown") ~ "9",
           vaxmfr4 %in% c("AstraZeneca","AstraZen") ~ "5",
           vaxmfr4 %in% c("NVX","Novavax") ~ "6",
           vaxmfr4 %in% c("1", "2", "3", "4", "5", "9","6") ~ vaxmfr4,
           is.na(vaxmfr4) ~ NA_character_),
         vrvac_covid19_man5 = case_when(
           vaxmfr5 %in% c("Pfizer", "PFR","PFIZER") ~ "1",
           vaxmfr5 %in% c("Moderna","MOD","MODERNA") ~ "2",
           vaxmfr5 %in% c("Janssen","JSN","Johnson and Johnson") ~ "4",
           vaxmfr5 %in% c("Unknown manufacturer", "Unknown") ~ "9",
           vaxmfr5 %in% c("AstraZeneca","AstraZen") ~ "5",
           vaxmfr5 %in% c("NVX","Novavax") ~ "6",
           vaxmfr5 %in% c("1", "2", "3", "4", "5", "9","6") ~ vaxmfr5,
           is.na(vaxmfr5) ~ NA_character_),
         vrvac_covid19_man6 = case_when(
           vaxmfr6 %in% c("Pfizer", "PFR","PFIZER") ~ "1",
           vaxmfr6 %in% c("Moderna","MOD","MODERNA") ~ "2",
           vaxmfr6 %in% c("Janssen","JSN","Johnson and Johnson") ~ "4",
           vaxmfr6 %in% c("Unknown manufacturer", "Unknown") ~ "9",
           vaxmfr6 %in% c("AstraZeneca","AstraZen") ~ "5",
           vaxmfr6 %in% c("NVX","Novavax") ~ "6",
           vaxmfr6 %in% c("1", "2", "3", "4", "5", "9","6") ~ vaxmfr6,
           is.na(vaxmfr6) ~ NA_character_),

         outcome = case_when(
           death_yn %in% c("no", "No","0") ~ "1",
           death_yn %in% c("yes", "Yes","1") ~ "2",
           death_yn == "Unknown" | is.na(death_yn) | death_yn == "unk" ~ "9"),
         covtesttype = case_when(
           test_pcr %in% c("Positive","1") ~ "1"))   %>%
           #test_other == "Positive" & test_other_spec == "Antigen" ~ "2"))

  select(-race_aian, -race_asian, -race_black, -race_nhpi, -race_white, -race_unk, -race_other, -vaxmfr1, -vaxmfr2, -vaxmfr3, -vaxmfr4, -vaxmfr5, -vaxmfr6, -hosp_yn,-death_yn, -test_pcr, -test_other, -test_other_spec)  %>%  

  # this last variable is created for consistency with REDCAP template - all of the DCIPHER-reporting jurisdictions have confirmed that they only enter death_yn (above) == yes if they determine the death is COVID-associated
  mutate(death_related = if_else(outcome == "2", "1", NA_character_))

# then, once this section above works as intended, replace upload_data with this dcipher set and remove dcipher to conserve memory space in R
upload_data<-dcipher
rm(dcipher)

}

# Check here for redcap jurisdictions - any missing vaccine dose variables? If so, add as an NA column:
if(!("vrvac_covid19_dt3" %in% names(upload_data))){upload_data$vrvac_covid19_dt3 <- NA}
if(!("vrvac_covid19_dt4" %in% names(upload_data))){upload_data$vrvac_covid19_dt4 <- NA}
if(!("vrvac_covid19_dt5" %in% names(upload_data))){upload_data$vrvac_covid19_dt5 <- NA}
if(!("vrvac_covid19_dt6" %in% names(upload_data))){upload_data$vrvac_covid19_dt6 <- NA}
if(!("vrvac_covid19_man3" %in% names(upload_data))){upload_data$vrvac_covid19_man3 <- NA_character_}
if(!("vrvac_covid19_man4" %in% names(upload_data))){upload_data$vrvac_covid19_man4 <- NA_character_}
if(!("vrvac_covid19_man5" %in% names(upload_data))){upload_data$vrvac_covid19_man5 <- NA_character_}
if(!("vrvac_covid19_man6" %in% names(upload_data))){upload_data$vrvac_covid19_man6 <- NA_character_}
# if(!("vaxtype1" %in% names(upload_data))){upload_data$vaxtype1 <- NA_character_}
# if(!("vaxtype2" %in% names(upload_data))){upload_data$vaxtype2 <- NA_character_}
# if(!("vaxtype3" %in% names(upload_data))){upload_data$vaxtype3 <- NA_character_}
# if(!("vaxtype4" %in% names(upload_data))){upload_data$vaxtype4 <- NA_character_}
# if(!("vaxtype5" %in% names(upload_data))){upload_data$vaxtype5 <- NA_character_}
# if(!("vaxtype6" %in% names(upload_data))){upload_data$vaxtype6 <- NA_character_}

if(!("vrvac_covid19_type1" %in% names(upload_data))){upload_data$vrvac_covid19_type1 <- NA_character_}
if(!("vrvac_covid19_type2" %in% names(upload_data))){upload_data$vrvac_covid19_type2 <- NA_character_}
if(!("vrvac_covid19_type3" %in% names(upload_data))){upload_data$vrvac_covid19_type3 <- NA_character_}
if(!("vrvac_covid19_type4" %in% names(upload_data))){upload_data$vrvac_covid19_type4 <- NA_character_}
if(!("vrvac_covid19_type5" %in% names(upload_data))){upload_data$vrvac_covid19_type5 <- NA_character_}
if(!("vrvac_covid19_type6" %in% names(upload_data))){upload_data$vrvac_covid19_type6 <- NA_character_}


df <- upload_data %>% 
  unique() %>% # remove exact duplicate records (noticed this was occurring with NC)
  rename(dobC = dob) %>% 
  rownames_to_column(var = "master_id") # easy reference to later eliminate specific cases, since jurisdictions put their unique case IDs in different variables

#n exact dups removed:
n_exact_dups <- nrow(upload_data) - nrow(df)
  
# # because there is so much data, retaining all the variables in each data processing step is too much for R to handle
# the master_id variable is used at the end to join the final variables with the original variables before outputting files

# make an indicator variable for if the jurisdiction is a booster reporter or not
booster_reporter<-ifelse(sum(is.na(df$vrvac_covid19_dt3))==nrow(df),"No","Yes")

# make an indicator variable for if the jurisdiction is a second booster reporter or not
second_booster_reporter<-ifelse(sum(is.na(df$vrvac_covid19_dt4))==nrow(df),"No","Yes")

# set a variable for the original number of cases submitted
n_submitted<-nrow(df)
```

# Inclusion of Cases Meeting VIBS Criteria

## Check 1

Unexpected missingness of essential variables for specific jurisdictions. Look for unexpected findings; for example, a jurisdiction missing all values for a variable might indicate they didn't include that variable with their submission. Note which jurisdictions are totally missing information for variables related to vaccine doses 3, 4, and 5, as those do not report booster doses.

```{r var_missingness_1}
# quick check to make sure all essential variables are present in the data:

# variables required to create vaccination status and product classifications
essentialVars <- c("dobC", "covtestdt", "vrvac_covid19_dt1", "vrvac_covid19_dt2", "vrvac_covid19_dt3", "vrvac_covid19_dt4", "vrvac_covid19_dt5","vrvac_covid19_dt6", "vrvac_covid19_man1", "vrvac_covid19_man2", "vrvac_covid19_man3", "vrvac_covid19_man4", "vrvac_covid19_man5", "vrvac_covid19_man6", "outcome", "death_related", "juris", "master_id","vrvac_covid19_type1","vrvac_covid19_type2","vrvac_covid19_type3","vrvac_covid19_type4","vrvac_covid19_type5","vrvac_covid19_type6")

essential_var_check<-""
for (i in 1:length(essentialVars)){
  if(!(essentialVars[i] %in% names(df))){essential_var_check<-paste0(essential_var_check,"Missing ",essentialVars[i]," ")}}

# check this internally:
# Are any essential variables missing entirely from the dataset (i.e. the column is missing and a placeholder needs to be added):
essential_var_check
# If none are missing, this will be blank:
```

```{r var_missingness_2, include=TRUE}
# ok if 3rd dose variables missing if they're not a booster reporter, like AZ

# LRL update: add formatted table here with built in checks
missing_check<-df %>%
  select(all_of(essentialVars)) %>%
  summarize(across(all_of(essentialVars),list(".Missing_n"=function(x) sum(is.na(x)),
                                              ".Reported_n"=function(x) sum(is.na(x)==F),
                                              ".Percent_missing"=function(x) round(mean(is.na(x)*100),1))))
# reformat table from wide to long
missing_check.tidy <- missing_check %>% 
  gather(stat, val) %>% # wide to long - not perfect yet at this step since it creates a row for every iteration of variable x stat, and we want just one row per variable
  separate(stat, into = c("Variable", "stat"), sep = "[.]") %>% # separate the first variable into two so we can group on just variable name
  mutate(Variable=substr(Variable,1,nchar(Variable)-1)) %>%   # get rid of the extra _
  spread(stat,val) %>% # go from all long back to wider - condense to one row per variable with the stats as columns
  select(Variable,Missing_n, Reported_n, Percent_missing) # reorder variables

# take out the percent missing for death_related, since it's a bit misleading (should always be really high given that all the 'no' responses turned to NA)
missing_check.tidy$Percent_missing[missing_check.tidy$Variable=="death_related"]<-NA
missing_check.tidy$Percent_missing<-as.numeric(missing_check.tidy$Percent_missing)

# output nicely with kable package
kable(missing_check.tidy,format="html" ,booktabs=T,align="lrrr",toprule = "\\toprule") %>%
  row_spec(as.numeric(row.names(missing_check.tidy )[is.na(missing_check.tidy$Percent_missing)==F & missing_check.tidy$Missing_n==0]),background="#a1d99b") %>% # color row dark green if none missing
  row_spec(as.numeric(row.names(missing_check.tidy )[is.na(missing_check.tidy$Percent_missing)==F & missing_check.tidy$Missing_n>0 & missing_check.tidy$Percent_missing<=1]),background="#c7e9c0") %>% # color row light green if =<1% missing (can change this to whatever threshold)
  row_spec(as.numeric(row.names(missing_check.tidy )[is.na(missing_check.tidy$Percent_missing)==F & missing_check.tidy$Percent_missing>1 & missing_check.tidy$Reported_n!=0]),background="#ffeda0") %>% # color row yellow if >1% and <100% missing (can change this to whatever threshold)
  row_spec(as.numeric(row.names(missing_check.tidy )[is.na(missing_check.tidy$Percent_missing)==F & missing_check.tidy$Reported_n==0]),background="#fc9272") %>% # color row red if all missing?
  column_spec(1:4,width="1.5in") %>%
  row_spec(0, align = "c") 
  

#LRL notes:
# In general, wondering if there is a good rule of thumb for % missing data that would make us concerned. Personally find it's often hard to assess these things at a glance. I added some arbitrary thresholds to color code. 

```

## Check 2

Missingness of positive specimen collection date and positive specimen collection dates outside the desired range.

First, all dates are formatted behind the scenes.

```{r dateFormatting}
# Check date formats relative to date formatting code below
dates <- c("covtestdt", "dobC", "vrvac_covid19_dt1", "vrvac_covid19_dt2", "vrvac_covid19_dt3", "vrvac_covid19_dt4", "vrvac_covid19_dt5","vrvac_covid19_dt6")

for (i in 1:length(dates)) {
  
  print(dates[i])  
  print(lapply(df[dates[i]], function(x) {head(x, n=50)}))
} 

# LRL note: Is there any concern that date vars may shift in formatting throughout these files? This code ^ looks at the first 50 values, which should be the same each time since the files are cumulative. If concern about dates changing format throughout, may want a check that assesses all entered dates?
# ex: looks like KS data may have a mix of date and datetime for covtestdt? doesn't seem to be an issue, but just one example

# make sure all dates used 4-digit year; if 2-digit year is used, use of lubridate functions will classify some birthdates as 20xx instead of 19xx and a different function is needed

excelStates <- c("AR", "KS", "DC","NJ","GA") # include states that provide XLS/XLSX linelists b/c their dates require different formatting

df <- 
  df %>% 
  rename(vaxmfr1 = vrvac_covid19_man1, vaxmfr2 = vrvac_covid19_man2, vaxmfr3 = vrvac_covid19_man3, vaxmfr4 = vrvac_covid19_man4, vaxmfr5 = vrvac_covid19_man5, vaxmfr6 = vrvac_covid19_man6) %>% 
  mutate(
    pos_test_date = case_when(
      juris %in% excelStates ~ excelDates(covtestdt), 
      #juris == "NC" ~ as.Date(covtestdt, format = "%d%B%Y"),
      #juris == "NC" ~ as.Date(covtestdt, format = "%d-%B-%Y"),
      juris == "CT" ~ ymd(covtestdt), 
      TRUE ~ mdy(covtestdt)), 
    
    dob = case_when(
      juris %in% excelStates ~ excelDates(dobC), 
      #juris == "NC" ~ as.Date(dobC, format = "%d-%b-%Y"),
      #juris == "NC" ~ as.Date(dobC, format = "%m/%d/%Y"),
      juris == "RI" ~ as.Date(dobC, format = "%Y-%m-%d"),
      juris == "CT" ~ ymd(dobC), 
      TRUE ~ mdy(dobC)), 
    
    vaxdate1 = case_when(
      juris %in% excelStates ~ excelDates(vrvac_covid19_dt1),
      #juris == "NC" ~ as.Date(vrvac_covid19_dt1, format = "%d%B%Y"), 
      #juris == "NC" ~ as.Date(vrvac_covid19_dt1, format = "%d-%B-%Y"),
      juris == "CT" ~ ymd(vrvac_covid19_dt1), 
      TRUE ~ mdy(vrvac_covid19_dt1)),
    
    vaxdate2 = case_when(
      juris %in% excelStates ~ excelDates(vrvac_covid19_dt2), 
      #juris == "NC" ~ as.Date(vrvac_covid19_dt2, format = "%d%B%Y"), 
      #juris == "NC" ~ as.Date(vrvac_covid19_dt2, format = "%d-%B-%Y"),
      juris == "CT" ~ ymd(vrvac_covid19_dt2), 
      TRUE ~ mdy(vrvac_covid19_dt2)),
    
    vaxdate3 = case_when(
      juris %in% excelStates ~ excelDates(vrvac_covid19_dt3), 
      #juris == "NC" ~ as.Date(vrvac_covid19_dt3, format = "%d%B%Y"),
      #juris == "NC" ~ as.Date(vrvac_covid19_dt3, format = "%d-%B-%Y"),
      juris == "CT" ~ ymd(vrvac_covid19_dt3), 
      TRUE ~ mdy(vrvac_covid19_dt3)),
    
    vaxdate4 = case_when(
      juris %in% excelStates ~ excelDates(vrvac_covid19_dt4), 
      #juris == "NC" ~ as.Date(vrvac_covid19_dt4, format = "%d%B%Y"), 
      #juris == "NC" ~ as.Date(vrvac_covid19_dt4, format = "%d-%B-%Y"),
      juris == "CT" ~ ymd(vrvac_covid19_dt4), 
      TRUE ~ mdy(vrvac_covid19_dt4)),
    
    vaxdate5 = case_when(
      juris %in% excelStates ~ excelDates(vrvac_covid19_dt5), 
      #juris == "NC" ~ as.Date(vrvac_covid19_dt5, format = "%d%B%Y"),
      #juris == "NC" ~ as.Date(vrvac_covid19_dt5, format = "%d-%B-%Y"),
      juris == "CT" ~ ymd(vrvac_covid19_dt5), 
      TRUE ~ mdy(vrvac_covid19_dt5)),
    
    vaxdate6 = case_when(
      juris %in% excelStates ~ excelDates(vrvac_covid19_dt6), 
      #juris == "NC" ~ as.Date(vrvac_covid19_dt6, format = "%d%B%Y"),
      #juris == "NC" ~ as.Date(vrvac_covid19_dt6, format = "%d-%B-%Y"),
      juris == "CT" ~ ymd(vrvac_covid19_dt6), 
      TRUE ~ mdy(vrvac_covid19_dt6))) 

# Check warnings generated; should be only warnings indicating NAs introduced by coercion, which is fine since we expect missing dates

dates <- data.frame(orig = dates, new = c("pos_test_date", "dob", "vaxdate1", "vaxdate2", "vaxdate3", "vaxdate4", "vaxdate5","vaxdate6")) # make sure the new dates are entered in the same order as the old dates they correspond to

# check for perfect concordance between the two to make sure every observation with a date has a filled-in date-formatted variable
date_check_table<-c() # start by creating a blank date_check_table outside of the loop

# loop through each date in "dates", and add a row for each date to the date_check_table created above noting if it is concordant or not
for (i in 1:nrow(dates)) {
  print(dates[i,2]) # original code examining the dates
  print(table(is.na(df[[dates[i,1]]]), is.na(df[[dates[i,2]]])))
  
  # first, make a data frame out of the same table created above to be able to reference the columns
  date_check<-as.data.frame(table(is.na(df[[dates[i,1]]]), is.na(df[[dates[i,2]]])))
  
  date_check_flag<-"Concordant" # set the flag variable to "concordant" by default
  for(j in 1:nrow(date_check)){
    if((date_check$Var1[j]=="FALSE" & date_check$Var2[j]=="TRUE" & date_check$Freq[j]>0) | (date_check$Var1[j]=="TRUE" & date_check$Var2[j]=="FALSE" & date_check$Freq[j]>0)){
      date_check_flag<-"Discordant" # update the flag to "discordant" if any are found with a date entered initially that did not get formatted in the new corresponding variable (i.e. returned NA)
    }
  }
  date_check_table<-rbind(date_check_table,c(dates$orig[i],date_check_flag))
            
}
date_check_table<-as.data.frame(date_check_table) # turn the resulting table into a dataframe and set column headings
names(date_check_table)<-c("Variable","Check")

# results for each old v new date variable comparison should result in all entries falling in TRUE/TRUE or FALSE/FALSE categories; if some discordant missingness, need to investigate further and see what the original entry looked like

# output concordance check nicely with kable package:
kable(date_check_table,booktabs=T,align="l") %>%
  row_spec(as.numeric(row.names(date_check_table)[date_check_table$Check=="Concordant"]),background="#a1d99b") %>% # color row green if passed check
  row_spec(as.numeric(row.names(date_check_table)[date_check_table$Check=="Discordant"]),background="#fc9272") %>% # color row red if flagged
  column_spec(1:2,width="1.5in")

# missingness of pos_test_date
naCheck(df$pos_test_date) # for raw number of cases; flag if it's a large number

pct_missing <- df %>%
  summarise(n_cases = n(),
            n_na_pos_test_date = sum(is.na(pos_test_date)),
            pct_na_pos_test_date = (n_na_pos_test_date / n_cases)*100)

# LRL note: where are these actually taken out, if there are any? do they need to be explicitly removed somewhere? I added this to section below
```

`r pct_missing$n_na_pos_test_date` cases from `r jurisdiction` will be excluded because they are missing a positive specimen collection date. This translates to `r pct_missing$pct_na_pos_test_date`% missingness of the positive specimen collection date.

Cases are additionally filtered out if their positive specimen collection date is before the surveillance start date or after the current month's last date for case inclusion. Below is a summary of the positive specimen collection dates after applying this filtering criteria.

```{r date_range, include=TRUE}
# check the date range of the positive test dates and make sure that we have information at least through the latest date for case reporting
summary(df$pos_test_date) # if max date is less than the latest date for case reporting, check with Heather about whether we should ask for new data

# LRL note: good place for a flag ^
# make a simple one-row table displaying the max date submitted, the date we requested as the max, and a flag variable indicating if they submitted up to the date we wanted
date_range_check<-ifelse(max(df$pos_test_date,na.rm=T) < case_end_date,"Flagged","Passed") 
date_range_check_table<-as.data.frame(list(format(max(df$pos_test_date,na.rm=T),"%m/%d/%Y"),format(case_end_date,"%m/%d/%Y"),date_range_check))
names(date_range_check_table)<-c("Max submitted pos test date","Latest date for case reporting","Flag")

# output check table nicely with kable package:
kable(date_range_check_table,booktabs=T,align="c") %>%
  row_spec(1,background=ifelse(date_range_check_table$Flag=="Passed","#a1d99b","#fc9272")) %>% # color row green if passed check
  column_spec(1:3,width="1.5in")

# for the exclusions summary table at end of this document, note how many cases submitted before start of requested range and after end of range
n_before_range<-sum(df$pos_test_date<surv_start_date,na.rm=T)
n_after_range<-sum(df$pos_test_date>case_end_date,na.rm=T)

# exclude cases that occur outside of the requested date range to reduce memory required 
# LRL note: added to filter here to explicitly remove those missing pos_test_date
df <- df %>% 
  filter(is.na(pos_test_date)==F,
         pos_test_date >= surv_start_date, 
         pos_test_date <= case_end_date) # also excluding cases after this month's cutoff

```

## Check 3

We include cases if they are at least 6 months of age at the time of the positive specimen's collection. However, some cases may not have date of birth documented, and have to be excluded.

```{r missing_age_info}
# check missingness of date of birth and adding cut off for DOBs in 1900. 
missing_dob <- 
  df %>% 
  filter(is.na(dob)) %>% 
  summarise(n_na_age = n()) %>% 
  mutate(n_cases = nrow(df), 
         pct_na_age = (n_na_age / n_cases)*100) 

summary(df$dob)
#df <- df %>% filter(as.Date(dob) > as.Date("1900-01-01"))
```

`r missing_dob$n_na_age` cases from `r jurisdiction` will be excluded because the date of birth is missing. This translates to `r missing_dob$pct_na_age`% missingness of age information.

```{r calc_age, include=T}

df <- 
  df %>% 
  # filter out those missing dob
  filter(!is.na(dob)) %>% 
  mutate(age_calc = floor(as.duration(interval(dob , pos_test_date)) / dyears()),
         age_months = floor(as.duration(interval(dob,pos_test_date))/dmonths()))

if("age" %in% names(df)){
age_table<-as.data.frame(table(round(as.numeric(df$age)-as.numeric(df$age_calc))))
names(age_table)<-c("Difference between submitted and calculated age (years)","N")

kable(age_table,full_width = F) %>%
  column_spec(1,width="2in") %>%
  column_spec(2,width="1in") }


# Note that NC had a bunch coming in with calculated age really off from the submitted age due to DOB coding issues
# if the difference between the submitted and calculated ages is really big, default to the submitted age 
# do this just for NC for now, for age differences of 100+, and then add a table to show discrepancies for other jurs
if(params$juris=="NC"){
df<-df %>%
  mutate(age_calc=ifelse(as.numeric(age)-as.numeric(age_calc)>99,as.numeric(age),age_calc))
}


summary(df$age_calc) # check if negative values present in the minimum

agewonky <- 
  df %>% 
  filter(age_calc < 0) %>% 
  tally() %>% 
  mutate(n_cases = nrow(df), 
         pct_imp_age = (n / n_cases)*100)

# negative_age <- df %>% 
#   filter(age_calc < 0)
# negative_age <- negative_age[ , c('local_id', 'dob', 'dobC', 'pos_test_date', 'age_calc')]
# dob <- df[, c('dob', 'dobC')]

# agewonky_date <-
# df %>%
# filter(dob == "1900-01-01" | dob == "1901-01-01") %>%
# tally() %>%
# mutate(n_cases = nrow(df),
# pct_imp_date = (n/n_cases)*100)
```

After calculating age on the date of the positive specimen collection, `r agewonky$n` cases had a negative age calculated and will be excluded. This translates to `r agewonky$pct_imp_age`% of cases where an age could be calculated.

```{r document_wonkyage}

# now filter to only include those with a sensible calculated age, then create age groups and additionally filter out the under-5s
df <- 
  df %>% 
  filter(age_calc >= 0) %>% 
  mutate(age_grp = case_when(
    age_calc == 0 & age_months < 6 ~ "exclude",
    age_calc == 0 & age_months >=6 ~ "0.5-4",
    age_calc >=1 & age_calc < 5 ~ "0.5-4",
    age_calc >= 5 & age_calc < 12 ~ "5-11",
    age_calc >= 12 & age_calc < 18 ~ "12-17", 
    age_calc >= 18 & age_calc < 30 ~ "18-29", 
    age_calc >= 30 & age_calc < 50 ~ "30-49", 
    age_calc >= 50 & age_calc < 65 ~ "50-64", 
    age_calc >= 65 & age_calc < 80 ~ "65-79", 
    age_calc >= 80  ~ "80+", 
    TRUE ~ "check")) # even though hard coding is less elegant, allows for easy changes in future

table(df$age_grp, useNA = "ifany") # note number of cases unassigned to an age group (i.e. their age_calc is < 6 months)

too_young <- df %>% filter(age_grp == "exclude")

# exclude cases less than 6 months old
df <- df %>% filter(age_grp != "exclude")

n_fillerDOB<-sum(df$dob %in% c("1900-01-01","1901-01-01"))
# excluding cases with a filler DOB
df <- df %>% filter(dob != "1900-01-01" & dob != "1901-01-01")
```

We also exclude cases \<6 months old on the positive specimen collection day. `r jurisdiction` has `r nrow(too_young)` cases that are \<6 months and will be excluded.

```{r calc_epiweekinfo}
# create MMWR week variable and composite year+MMWR week variable consistent with aggregate template formatting

epiyearweek <- function(dt) {
  as.numeric(paste0(epiyear(dt), if_else(nchar(epiweek(dt)) == 1, paste0("0", epiweek(dt)), paste0(epiweek(dt)))))
}

df <- 
  df %>% 
  mutate(mmwr_wk = if_else(nchar(epiweek(pos_test_date)) == 1, paste0("0", epiweek(pos_test_date)), paste0(epiweek(pos_test_date))), 
         year = epiyear(pos_test_date), 
         year_mmwr_wk = epiyearweek(pos_test_date))

summary(as.numeric(df$mmwr_wk)) # confirm expected range; week 53 is for Jan 1/2 cases since those are technically week 53 for 2020
summary(df$year) # confirm expected range; should be 2021 to 2022 
summary(df$year_mmwr_wk)

```

## Check 4

Cases where a vaccine manufacturer is entered but a vaccination date is missing. Check to see if there are any systematic issues (i.e., a large number of discordant entries).

```{r vaxmfr_and_concordancy}
# all vaxmfrs at this point should have values of 1, 2, 3, 4, 5, or 9 (NA is also ok), and now 6 - anything else will need cleaning if REDCAP template isn't updated
unique(df$vaxmfr1)
unique(df$vaxmfr2)
unique(df$vaxmfr3)
unique(df$vaxmfr4)
unique(df$vaxmfr5)
unique(df$vaxmfr6)

# LRL note: good place for a flag indicating if any of the values are off?

## This function 
### 1) Imputes "9" if date entered but no manufacturer information
### 2) Recodes all non-FDA manufacturers as a single "5" to simplify assignment of vaccine product
### 3) Recodes Novavax to 9 for unknown
mfr_recode <- 
  function(mfr, date) {
    case_when(
      mfr %in% c("1", "2", "4", "9") ~ mfr, 
      mfr %in% c("3", "5") ~ "5", # can add other non-FDA-approved vaccine values in this line as needed
      mfr == "6" ~ "9", # group Novavax with the unknowns for now
      is.na(mfr) & !is.na(date) ~ "9",
      is.na(mfr) & is.na(date) ~ mfr,
      TRUE ~ "check") # make sure all identified values are explicitly included before TRUE ~ line, since anything else not accounted for in prior code will have a value of "check" entered
  }
## this function returns either T or F if a value is missing (TRUE) or not missing (FALSE)
t.f <- function(x) {substr(is.na(x),1,1)}

df <- 
  df %>% 
  # creating new variables resulting from the recoding function; this preserves original data just in case there are questions
  mutate(vaxmfr1_rc = mfr_recode(vaxmfr1, vaxdate1), 
         vaxmfr2_rc = mfr_recode(vaxmfr2, vaxdate2), 
         vaxmfr3_rc = mfr_recode(vaxmfr3, vaxdate3), 
         vaxmfr4_rc = mfr_recode(vaxmfr4, vaxdate4), 
         vaxmfr5_rc = mfr_recode(vaxmfr5, vaxdate5), 
         vaxmfr6_rc = mfr_recode(vaxmfr6, vaxdate6), 
         
         vaxCourse = paste(vaxmfr1_rc, vaxmfr2_rc, vaxmfr3_rc, vaxmfr4_rc, vaxmfr5_rc, sep = "/"), # composite of all the mfr entries a case has
         dateSeq = paste(t.f(vaxdate1), t.f(vaxdate2), t.f(vaxdate3), t.f(vaxdate4), t.f(vaxdate5), sep = "/"), # composite of whether or not each date entry is missing
         mfrSeq = paste(t.f(vaxmfr1_rc), t.f(vaxmfr2_rc), t.f(vaxmfr3_rc), t.f(vaxmfr4_rc), t.f(vaxmfr5_rc), sep = "/"), # composite of whether or not each mfr entry is missing
         dose_agree = if_else(dateSeq == mfrSeq, 1, 0)) # whether missingness of dates and mfrs is synced

table(df$dose_agree) # assess how many instances of a mfr entered but a date missing exist

discordant <- df %>% filter(dose_agree == 0)

concordant <- df %>% filter(dose_agree == 1)

```

`r jurisdiction` has `r nrow(discordant)` cases where a vaccine manufacturer is entered but a corresponding date is missing. This represents `r nrow(discordant)/nrow(df)*100`% of their submitted fully vaccinated cases. These cases were excluded.

The below table lists which doses had the vaccine manufacturer but no corresponding date:

```{r discordant_by_dose, include=T}
# would be good to keep track of which exact doses are more affected by any discordant doses identified above 
# since there are many fewer people with 4+ doses, want to track if the percent of doses this affects varies by dose number (as seen in RI which prompted f/u with them and identified a coding error)

discordant_dose_table<-rbind(c("Dose 1:",paste0(sum(is.na(df$vaxmfr1_rc)==F & is.na(df$vaxdate1)),", (",round((sum(is.na(df$vaxmfr1_rc)==F & is.na(df$vaxdate1))/sum(is.na(df$vaxmfr1_rc)==F))*100,2),"%)")),
                             c("Dose 2:",paste0(sum(is.na(df$vaxmfr2_rc)==F & is.na(df$vaxdate2)),", (",round((sum(is.na(df$vaxmfr2_rc)==F & is.na(df$vaxdate2))/sum(is.na(df$vaxmfr2_rc)==F))*100,2),"%)")),
                             c("Dose 3:",paste0(sum(is.na(df$vaxmfr3_rc)==F & is.na(df$vaxdate3)),", (",round((sum(is.na(df$vaxmfr3_rc)==F & is.na(df$vaxdate3))/sum(is.na(df$vaxmfr3_rc)==F))*100,2),"%)")),
                             c("Dose 4:",paste0(sum(is.na(df$vaxmfr4_rc)==F & is.na(df$vaxdate4)),", (",round((sum(is.na(df$vaxmfr4_rc)==F & is.na(df$vaxdate4))/sum(is.na(df$vaxmfr4_rc)==F))*100,2),"%)")),
                             c("Dose 5:",paste0(sum(is.na(df$vaxmfr5_rc)==F & is.na(df$vaxdate5)),", (",round((sum(is.na(df$vaxmfr5_rc)==F & is.na(df$vaxdate5))/sum(is.na(df$vaxmfr5_rc)==F))*100,2),"%)")),
                             c("Dose 6:",paste0(sum(is.na(df$vaxmfr6_rc)==F & is.na(df$vaxdate6)),", (",round((sum(is.na(df$vaxmfr6_rc)==F & is.na(df$vaxdate6))/sum(is.na(df$vaxmfr6_rc)==F))*100,2),"%)")))

kable(discordant_dose_table)
```

$~$

The table below shows how many doses had a "9" (aka "unknown") entered for the manufacturer, but a corresponding CVX code for Pfizer, Moderna, or Janssen. These will be re-coded to defer to the CVX code. Note not recording Novavax (211) for now, as we're keeping those grouped with the unknowns. 

```{r cvx_missing_mfr, include=T}
# at this point, check for doses that have the cvx code available (for pfizer, moderna, or janssen) but a missing manufacturer

# make a table to track how often this happens?
cvx_missing_mfr_table<-concordant %>%
  summarize(dose1=paste0(sum(vaxmfr1_rc=="9" & vrvac_covid19_type1 %in% c("208","217","218","219","300","301","207","221","228","229","212","230","302"),na.rm=T), " (",
                         round((sum(vaxmfr1_rc=="9" & vrvac_covid19_type1 %in% c("208","217","218","219","300","301","207","221","228","229","212","230","302"),na.rm=T)/sum(is.na(vaxmfr1_rc)==F))*100,1),"%)"),
            dose2=paste0(sum(vaxmfr2_rc=="9" & vrvac_covid19_type2 %in% c("208","217","218","219","300","301","207","221","228","229","212","230","302"),na.rm=T), " (",
                         round((sum(vaxmfr2_rc=="9" & vrvac_covid19_type2 %in% c("208","217","218","219","300","301","207","221","228","229","212","230","302"),na.rm=T)/sum(is.na(vaxmfr2_rc)==F))*100,1),"%)"),
            dose3=paste0(sum(vaxmfr3_rc=="9" & vrvac_covid19_type3 %in% c("208","217","218","219","300","301","207","221","228","229","212","230","302"),na.rm=T), " (",
                         round((sum(vaxmfr3_rc=="9" & vrvac_covid19_type3 %in% c("208","217","218","219","300","301","207","221","228","229","212","230","302"),na.rm=T)/sum(is.na(vaxmfr3_rc)==F))*100,1),"%)"),
            dose4=paste0(sum(vaxmfr4_rc=="9" & vrvac_covid19_type4 %in% c("208","217","218","219","300","301","207","221","228","229","212","230","302"),na.rm=T), " (",
                         round((sum(vaxmfr4_rc=="9" & vrvac_covid19_type4 %in% c("208","217","218","219","300","301","207","221","228","229","212","230","302"),na.rm=T)/sum(is.na(vaxmfr4_rc)==F))*100,1),"%)"),
            dose5=paste0(sum(vaxmfr5_rc=="9" & vrvac_covid19_type5 %in% c("208","217","218","219","300","301","207","221","228","229","212","230","302"),na.rm=T), " (",
                         round((sum(vaxmfr5_rc=="9" & vrvac_covid19_type5 %in% c("208","217","218","219","300","301","207","221","228","229","212","230","302"),na.rm=T)/sum(is.na(vaxmfr5_rc)==F))*100,1),"%)"),
            dose6=paste0(sum(vaxmfr6_rc=="9" & vrvac_covid19_type6 %in% c("208","217","218","219","300","301","207","221","228","229","212","230","302"),na.rm=T), " (",
                         round((sum(vaxmfr6_rc=="9" & vrvac_covid19_type6 %in% c("208","217","218","219","300","301","207","221","228","229","212","230","302"),na.rm=T)/sum(is.na(vaxmfr6_rc)==F))*100,1),"%)"))

kable(cvx_missing_mfr_table) %>%
  kable_styling(position="left",full_width=F)

# recode the missing manufacturers to match the cvx codes
concordant <- concordant %>%
  mutate(vaxmfr1_rc=case_when(is.na(vaxmfr1_rc) | vaxmfr1_rc %in% c("1","2","4","5") ~ vaxmfr1_rc,
                              vaxmfr1_rc=="9" & vrvac_covid19_type1 %in% c("212") ~ "4",
                              vaxmfr1_rc=="9" & vrvac_covid19_type1 %in% c("208","217","218","219","300","301","302") ~ "1",
                              vaxmfr1_rc=="9" & vrvac_covid19_type1 %in% c("207","221","228","229","230") ~ "2",
                              T ~ vaxmfr1_rc),
         vaxmfr2_rc=case_when(is.na(vaxmfr2_rc) | vaxmfr2_rc %in% c("1","2","4","5") ~ vaxmfr2_rc,
                              vaxmfr2_rc=="9" & vrvac_covid19_type2 %in% c("212") ~ "4",
                              vaxmfr2_rc=="9" & vrvac_covid19_type2 %in% c("208","217","218","219","300","301","302") ~ "1",
                              vaxmfr2_rc=="9" & vrvac_covid19_type2 %in% c("207","221","228","229","230") ~ "2",
                              T ~ vaxmfr2_rc),
         vaxmfr3_rc=case_when(is.na(vaxmfr3_rc) | vaxmfr3_rc %in% c("1","2","4","5") ~ vaxmfr3_rc,
                              vaxmfr3_rc=="9" & vrvac_covid19_type3 %in% c("212") ~ "4",
                              vaxmfr3_rc=="9" & vrvac_covid19_type3 %in% c("208","217","218","219","300","301","302") ~ "1",
                              vaxmfr3_rc=="9" & vrvac_covid19_type3 %in% c("207","221","228","229","230") ~ "2",
                              T ~ vaxmfr3_rc),
         vaxmfr4_rc=case_when(is.na(vaxmfr4_rc) | vaxmfr4_rc %in% c("1","2","4","5") ~ vaxmfr4_rc,
                              vaxmfr4_rc=="9" & vrvac_covid19_type4 %in% c("212") ~ "4",
                              vaxmfr4_rc=="9" & vrvac_covid19_type4 %in% c("208","217","218","219","300","301","302") ~ "1",
                              vaxmfr4_rc=="9" & vrvac_covid19_type4 %in% c("207","221","228","229","230") ~ "2",
                              T ~ vaxmfr4_rc),
         vaxmfr5_rc=case_when(is.na(vaxmfr5_rc) | vaxmfr5_rc %in% c("1","2","4","5") ~ vaxmfr5_rc,
                              vaxmfr5_rc=="9" & vrvac_covid19_type5 %in% c("212") ~ "4",
                              vaxmfr5_rc=="9" & vrvac_covid19_type5 %in% c("208","217","218","219","300","301","302") ~ "1",
                              vaxmfr5_rc=="9" & vrvac_covid19_type5 %in% c("207","221","228","229","230") ~ "2",
                              T ~ vaxmfr5_rc),
         vaxmfr6_rc=case_when(is.na(vaxmfr6_rc) | vaxmfr6_rc %in% c("1","2","4","5") ~ vaxmfr6_rc,
                              vaxmfr6_rc=="9" & vrvac_covid19_type6 %in% c("212") ~ "4",
                              vaxmfr6_rc=="9" & vrvac_covid19_type6 %in% c("208","217","218","219","300","301","302") ~ "1",
                              vaxmfr6_rc=="9" & vrvac_covid19_type6 %in% c("207","221","228","229","230") ~ "2",
                              T ~ vaxmfr6_rc))

# Add a step to recode the mfrs just for the cases when there's a bivalent booster but a "5" for the mfr (for MI's data...)
concordant <- concordant %>%
  mutate(vaxmfr1_rc=case_when(is.na(vaxmfr1_rc) | vaxmfr1_rc %in% c("1","2","4","9") ~ vaxmfr1_rc,
                              vaxmfr1_rc=="5" & vrvac_covid19_type1 %in% c("300","301","302") ~ "1",
                              vaxmfr1_rc=="5" & vrvac_covid19_type1 %in% c("229","230") ~ "2",
                              T ~ vaxmfr1_rc),
         vaxmfr2_rc=case_when(is.na(vaxmfr2_rc) | vaxmfr2_rc %in% c("1","2","4","9") ~ vaxmfr2_rc,
                              vaxmfr2_rc=="5" & vrvac_covid19_type2 %in% c("300","301","302") ~ "1",
                              vaxmfr2_rc=="5" & vrvac_covid19_type2 %in% c("229","230") ~ "2",
                              T ~ vaxmfr2_rc),
         vaxmfr3_rc=case_when(is.na(vaxmfr3_rc) | vaxmfr3_rc %in% c("1","2","4","9") ~ vaxmfr3_rc,
                              vaxmfr3_rc=="5" & vrvac_covid19_type3 %in% c("300","301","302") ~ "1",
                              vaxmfr3_rc=="5" & vrvac_covid19_type3 %in% c("229","230") ~ "2",
                              T ~ vaxmfr3_rc),
         vaxmfr4_rc=case_when(is.na(vaxmfr4_rc) | vaxmfr4_rc %in% c("1","2","4","9") ~ vaxmfr4_rc,
                              vaxmfr4_rc=="5" & vrvac_covid19_type4 %in% c("300","301","302") ~ "1",
                              vaxmfr4_rc=="5" & vrvac_covid19_type4 %in% c("229","230") ~ "2",
                              T ~ vaxmfr4_rc),
         vaxmfr5_rc=case_when(is.na(vaxmfr5_rc) | vaxmfr5_rc %in% c("1","2","4","9") ~ vaxmfr5_rc,
                              vaxmfr5_rc=="5" & vrvac_covid19_type5 %in% c("300","301","302") ~ "1",
                              vaxmfr5_rc=="5" & vrvac_covid19_type5 %in% c("229","230") ~ "2",
                              T ~ vaxmfr5_rc),
         vaxmfr6_rc=case_when(is.na(vaxmfr6_rc) | vaxmfr6_rc %in% c("1","2","4","9") ~ vaxmfr6_rc,
                              vaxmfr6_rc=="5" & vrvac_covid19_type6 %in% c("300","301","302") ~ "1",
                              vaxmfr6_rc=="5" & vrvac_covid19_type6 %in% c("229","230") ~ "2",
                              T ~ vaxmfr6_rc))
```


## Check 5  

Deduplication of dates. Vaccine doses are sometimes entered twice. We need to identify these duplicate entries and remove them. Currently, this code only assesses duplicate dates and does not assess whether the same manufacturer is entered for the duplicate dates. The later of the two entries is preserved to represent the presumption that a later entry represents an update/correction to the previous information. For example, if date1 and date2 are the same but mfr1 and mfr2 are different, we presume that the second entry is an update of the first entry and retain date2 and mfr2 only.

```{r dedup}

# case_when evaluates statements in order. Because we prioritize the last duplicate entry, we want to evaluate the match between the first and last possible entry first
concordant <- 
  concordant %>% 
  mutate(
    vaxdate1_dedup = vaxdate1, 
    vaxdate2_dedup = case_when(
      vaxdate2==vaxdate1 ~ NA_Date_,
      TRUE ~ vaxdate2), 
    vaxdate3_dedup = case_when(
      vaxdate3==vaxdate1 | vaxdate3==vaxdate2 ~ NA_Date_,
      TRUE ~ vaxdate3), 
    vaxdate4_dedup = case_when(
      vaxdate4==vaxdate1 | vaxdate4==vaxdate2 | vaxdate4==vaxdate3 ~ NA_Date_,
      TRUE ~ vaxdate4),
    vaxdate5_dedup = case_when(
      vaxdate5==vaxdate1 | vaxdate5==vaxdate2 | vaxdate5==vaxdate3 | vaxdate5==vaxdate4 ~ NA_Date_,
      TRUE ~ vaxdate5), 
    vaxdate6_dedup = case_when(
      vaxdate6==vaxdate1 | vaxdate6==vaxdate2 | vaxdate6==vaxdate3 | vaxdate6==vaxdate4 | vaxdate6==vaxdate5 ~ NA_Date_,
      TRUE ~ vaxdate6), 

    vaxmfr1_dedup =  vaxmfr1_rc, 
    vaxmfr2_dedup = case_when(
      vaxdate2==vaxdate1 ~ NA_character_,
      TRUE ~ vaxmfr2_rc), 
    vaxmfr3_dedup = case_when(
      vaxdate3==vaxdate1 | vaxdate3==vaxdate2 ~ NA_character_, 
      TRUE ~ vaxmfr3_rc), 
    vaxmfr4_dedup = case_when(
      vaxdate4==vaxdate1 | vaxdate4==vaxdate2 | vaxdate4==vaxdate3 ~ NA_character_, 
      TRUE ~ vaxmfr4_rc), 
    vaxmfr5_dedup = case_when(
      vaxdate5==vaxdate1 | vaxdate5==vaxdate2 | vaxdate5==vaxdate3 | vaxdate5==vaxdate4 ~ NA_character_, 
      TRUE ~ vaxmfr5_rc), 
    vaxmfr6_dedup = case_when(
      vaxdate6==vaxdate1 | vaxdate6==vaxdate2 | vaxdate6==vaxdate3 | vaxdate6==vaxdate4 | vaxdate6==vaxdate5 ~ NA_character_, 
      TRUE ~ vaxmfr6_rc),
    
    # whether mfr is NA for each entry (T = NA, F = not NA)
    mfrSeq = paste(t.f(vaxmfr1_dedup), t.f(vaxmfr2_dedup), t.f(vaxmfr3_dedup), t.f(vaxmfr4_dedup), t.f(vaxmfr5_dedup), t.f(vaxmfr6_dedup), sep = "/"), 
    
    # whether date is NA for each entry (T = NA, F = not NA)
    dateSeq = paste(t.f(vaxdate1_dedup), t.f(vaxdate2_dedup), t.f(vaxdate3_dedup), t.f(vaxdate4_dedup), t.f(vaxdate5_dedup), t.f(vaxdate6_dedup), sep = "/"), 
    
    # whether sequence of missingness for mfr and date agree
    dose_agree = if_else(mfrSeq == dateSeq, "1", "0"))

```

```{r dupe_check}
dupe_check <- concordant %>% 
  select(local_id,vaxdate1,vaxdate2,vaxdate3,vaxdate4,vaxdate5,vaxdate6) %>%
  mutate(yes = case_when(vaxdate1 == vaxdate2 ~1,
                         vaxdate1 == vaxdate3 ~1,
                         vaxdate1 == vaxdate4 ~1,
                         vaxdate1 == vaxdate5 ~1, 
                         vaxdate1 == vaxdate5 ~1, 
                         vaxdate2 == vaxdate3 ~1,
                         vaxdate2 == vaxdate4 ~1,
                         vaxdate2 == vaxdate5 ~1, 
                         vaxdate2 == vaxdate6 ~1, 
                         vaxdate3 == vaxdate4 ~1, 
                         vaxdate3 == vaxdate5 ~1,
                         vaxdate3 == vaxdate6 ~1, 
                         vaxdate4 == vaxdate5 ~1, 
                         vaxdate4 == vaxdate6 ~1, 
                         vaxdate5 == vaxdate6 ~1))

table(dupe_check$yes, useNA = "ifany")

pct_dupe <- dupe_check %>%
  summarise(n_cases = n(),
            n_yes = sum(yes, na.rm = TRUE),
            pct_yes = (n_yes / n_cases)*100)

```

After excluding the cases from the previous checks above, there are `r pct_dupe$n_cases` in which `r pct_dupe$n_yes` have a duplicate vaxdate. This amounts to `r pct_dupe$pct_yes`% of cases, thus far.


This month, we are adding a section to remove any non-FDA doses - these doses will now be set to NA and will not be considered in the assignment of vaccine product type.

```{r remove_nonFDA}
concordant$vaxdate1_dedup[is.na(concordant$vaxmfr1_dedup)==F & concordant$vaxmfr1_dedup=="5"]<-NA
concordant$vaxmfr1_dedup[is.na(concordant$vaxmfr1_dedup)==F & concordant$vaxmfr1_dedup=="5"]<-NA

concordant$vaxdate2_dedup[is.na(concordant$vaxmfr2_dedup)==F & concordant$vaxmfr2_dedup=="5"]<-NA
concordant$vaxmfr2_dedup[is.na(concordant$vaxmfr2_dedup)==F & concordant$vaxmfr2_dedup=="5"]<-NA

concordant$vaxdate3_dedup[is.na(concordant$vaxmfr3_dedup)==F & concordant$vaxmfr3_dedup=="5"]<-NA
concordant$vaxmfr3_dedup[is.na(concordant$vaxmfr3_dedup)==F & concordant$vaxmfr3_dedup=="5"]<-NA

concordant$vaxdate4_dedup[is.na(concordant$vaxmfr4_dedup)==F & concordant$vaxmfr4_dedup=="5"]<-NA
concordant$vaxmfr4_dedup[is.na(concordant$vaxmfr4_dedup)==F & concordant$vaxmfr4_dedup=="5"]<-NA

concordant$vaxdate5_dedup[is.na(concordant$vaxmfr5_dedup)==F & concordant$vaxmfr5_dedup=="5"]<-NA
concordant$vaxmfr5_dedup[is.na(concordant$vaxmfr5_dedup)==F & concordant$vaxmfr5_dedup=="5"]<-NA

concordant$vaxdate6_dedup[is.na(concordant$vaxmfr6_dedup)==F & concordant$vaxmfr6_dedup=="5"]<-NA
concordant$vaxmfr6_dedup[is.na(concordant$vaxmfr6_dedup)==F & concordant$vaxmfr6_dedup=="5"]<-NA


```



## Check 6

Skipped entries for vaccine history variables. An example of this is when information on vaccine doses is entered for doses 1 and 3, but not 2. Below tables provide a tabulation of values in the "fixing" of this issue, which provides an opportunity to make sure no indicators for unexpected scenarios are present.

```{r fix_skipped}
# Using an updated method for this, reducing the complexity over the first recode that replaced the permutation version

# First, make a variable for a comma-separated list of the non-missing vaccine dose variables for date and mfr:
concordant<-concordant %>%
  mutate(vaxdate_condense = paste(ifelse(is.na(vaxdate1_dedup)==F,as.character(vaxdate1_dedup),"Missing"),
                                  ifelse(is.na(vaxdate2_dedup)==F,as.character(vaxdate2_dedup),"Missing"),
                                  ifelse(is.na(vaxdate3_dedup)==F,as.character(vaxdate3_dedup),"Missing"),
                                  ifelse(is.na(vaxdate4_dedup)==F,as.character(vaxdate4_dedup),"Missing"),
                                  ifelse(is.na(vaxdate5_dedup)==F,as.character(vaxdate5_dedup),"Missing"),
                                  ifelse(is.na(vaxdate6_dedup)==F,as.character(vaxdate6_dedup),"Missing"),sep=","),
         vaxmfr_condense = paste(ifelse(is.na(vaxmfr1_dedup)==F,vaxmfr1_dedup,"Missing"),
                                  ifelse(is.na(vaxmfr2_dedup)==F,vaxmfr2_dedup,"Missing"),
                                  ifelse(is.na(vaxmfr3_dedup)==F,vaxmfr3_dedup,"Missing"),
                                  ifelse(is.na(vaxmfr4_dedup)==F,vaxmfr4_dedup,"Missing"),
                                  ifelse(is.na(vaxmfr5_dedup)==F,vaxmfr5_dedup,"Missing"),
                                  ifelse(is.na(vaxmfr6_dedup)==F,vaxmfr6_dedup,"Missing"),sep=","))


# Then, replace all the instances of "Missing" as they appear in the list. Note the order followed below is important! 
# The first two steps for each variable remove "Missing"s in the list in any slot (the second step is for when they appear as the very first dose in particular, noting comma placement)
# The third step is for when all doses are Missing - step one will leave it so all that is left is "Missing" without the comma, and for whatever reason it wasn't working to replace this with a blank space so these will be replaced with NA, which works with the rest of the code
concordant$vaxdate_condense <- gsub(",Missing","",concordant$vaxdate_condense)
concordant$vaxdate_condense <- gsub("Missing,","",concordant$vaxdate_condense)
concordant$vaxdate_condense <- gsub("Missing",NA,concordant$vaxdate_condense)
concordant$vaxmfr_condense <- gsub(",Missing","",concordant$vaxmfr_condense)
concordant$vaxmfr_condense <- gsub("Missing,","",concordant$vaxmfr_condense)
concordant$vaxmfr_condense <- gsub("Missing",NA,concordant$vaxmfr_condense)


# then can reference this list by index to make a set of new "fixed" variables
concordant<-concordant %>% 
  mutate(vaxdate1_fix = lapply(vaxdate_condense, function(x) strsplit(x,",")[[1]][1]),
         vaxdate2_fix = lapply(vaxdate_condense, function(x) strsplit(x,",")[[1]][2]),
         vaxdate3_fix = lapply(vaxdate_condense, function(x) strsplit(x,",")[[1]][3]),
         vaxdate4_fix = lapply(vaxdate_condense, function(x) strsplit(x,",")[[1]][4]),
         vaxdate5_fix = lapply(vaxdate_condense, function(x) strsplit(x,",")[[1]][5]),
         vaxdate6_fix = lapply(vaxdate_condense, function(x) strsplit(x,",")[[1]][6]),
         vaxmfr1_fix = lapply(vaxmfr_condense, function(x) strsplit(x,",")[[1]][1]),
         vaxmfr2_fix = lapply(vaxmfr_condense, function(x) strsplit(x,",")[[1]][2]),
         vaxmfr3_fix = lapply(vaxmfr_condense, function(x) strsplit(x,",")[[1]][3]),
         vaxmfr4_fix = lapply(vaxmfr_condense, function(x) strsplit(x,",")[[1]][4]),
         vaxmfr5_fix = lapply(vaxmfr_condense, function(x) strsplit(x,",")[[1]][5]),
         vaxmfr6_fix = lapply(vaxmfr_condense, function(x) strsplit(x,",")[[1]][6]) )

# convert all back to dates or characters from list type (does not work to include this as one function within lapply, for some reason...)
concordant<-concordant %>% 
  mutate(vaxdate1_fix = as.Date(as.character(vaxdate1_fix)),
         vaxdate2_fix = as.Date(as.character(vaxdate2_fix)),
         vaxdate3_fix = as.Date(as.character(vaxdate3_fix)),
         vaxdate4_fix = as.Date(as.character(vaxdate4_fix)),
         vaxdate5_fix = as.Date(as.character(vaxdate5_fix)),
         vaxdate6_fix = as.Date(as.character(vaxdate6_fix)),
         vaxmfr1_fix = as.character(vaxmfr1_fix),
         vaxmfr2_fix = as.character(vaxmfr2_fix),
         vaxmfr3_fix = as.character(vaxmfr3_fix),
         vaxmfr4_fix = as.character(vaxmfr4_fix),
         vaxmfr5_fix = as.character(vaxmfr5_fix),
         vaxmfr6_fix = as.character(vaxmfr6_fix) )

# make some variables to check this worked as intended:
concordant <- concordant %>% 
   mutate(
    vaxCourse_fix = paste(vaxmfr1_fix, vaxmfr2_fix, vaxmfr3_fix, vaxmfr4_fix, vaxmfr5_fix, vaxmfr6_fix, sep = "/"), 
    dateSeq_fix = paste(t.f(vaxdate1_fix), t.f(vaxdate2_fix), t.f(vaxdate3_fix), t.f(vaxdate4_fix), t.f(vaxdate5_fix),t.f(vaxdate6_fix), sep = "/"), 
    mfrSeq_fix = paste(t.f(vaxmfr1_fix), t.f(vaxmfr2_fix), t.f(vaxmfr3_fix), t.f(vaxmfr4_fix), t.f(vaxmfr5_fix),t.f(vaxmfr6_fix), sep = "/"), 
    dose_agree_fix = if_else(dateSeq_fix == mfrSeq_fix, "1", "0"))

```

No "check" values should be present.

```{r qc_fixmfr, include=TRUE}
#lapply(concordant %>% select(starts_with("vaxmfr") & ends_with("_fix")), unique)  

# LRL update: add formatted table here with built in checks

vaxmfr_fix_check<-as.data.frame(rbind(c("vaxmfr1_fix",paste(shQuote(unique(concordant$vaxmfr1_fix)),collapse=", "),ifelse("FALSE" %in% c(unique(concordant$vaxmfr1_fix) %in% c("1","2","4","5","9",NA)),"Flagged","Passed")),
                                      c("vaxmfr2_fix",paste(shQuote(unique(concordant$vaxmfr2_fix)),collapse=", "),ifelse("FALSE" %in% c(unique(concordant$vaxmfr2_fix) %in% c("1","2","4","5","9",NA)),"Flagged","Passed")),
                                      c("vaxmfr3_fix",paste(shQuote(unique(concordant$vaxmfr3_fix)),collapse=", "),ifelse("FALSE" %in% c(unique(concordant$vaxmfr3_fix) %in% c("1","2","4","5","9",NA)),"Flagged","Passed")),
                                      c("vaxmfr4_fix",paste(shQuote(unique(concordant$vaxmfr4_fix)),collapse=", "),ifelse("FALSE" %in% c(unique(concordant$vaxmfr4_fix) %in% c("1","2","4","5","9",NA)),"Flagged","Passed")),
                                      c("vaxmfr5_fix",paste(shQuote(unique(concordant$vaxmfr5_fix)),collapse=", "),ifelse("FALSE" %in% c(unique(concordant$vaxmfr5_fix) %in% c("1","2","4","5","9",NA)),"Flagged","Passed")),
                                      c("vaxmfr6_fix",paste(shQuote(unique(concordant$vaxmfr6_fix)),collapse=", "),ifelse("FALSE" %in% c(unique(concordant$vaxmfr6_fix) %in% c("1","2","4","5","9",NA)),"Flagged","Passed"))))

names(vaxmfr_fix_check)<-c("Variable","Values","Check")

kable(vaxmfr_fix_check,booktabs=T,align="lll") %>%
  row_spec(as.numeric(row.names(vaxmfr_fix_check)[vaxmfr_fix_check$Check=="Passed"]),background="#a1d99b") %>%
  row_spec(as.numeric(row.names(vaxmfr_fix_check)[vaxmfr_fix_check$Check=="Flagged"]),background="#ffeda0") %>% # color row yellow if flagged
  column_spec(c(1,3),width="1in") %>%
  column_spec(c(2),width="2.5in")

```
$~$

All dates should return FALSE or NA when checked if they equal the specified "check" date of `r checkDate` - i.e. all of the N "check" dates in the table below should be 0. 

```{r qc_fixdate, include=TRUE}
#lapply(concordant %>% select(starts_with("vaxdate") & ends_with("_fix")), function(x) {table(x == checkDate, useNA = "ifany")})

# note that the way I updated the above code, there will never be any check dates in these variables ever, so can probably remove this section...
# LRL update: switch to formatted table with check
vaxdate_check_table<-as.data.frame(rbind(c("vaxdate1_fix",sum(concordant$vaxdate1_fix==checkDate,na.rm=T)),
                                     c("vaxdate2_fix",sum(concordant$vaxdate2_fix==checkDate,na.rm=T)),
                                     c("vaxdate3_fix",sum(concordant$vaxdate3_fix==checkDate,na.rm=T)),
                                     c("vaxdate4_fix",sum(concordant$vaxdate4_fix==checkDate,na.rm=T)),
                                     c("vaxdate5_fix",sum(concordant$vaxdate5_fix==checkDate,na.rm=T)),
                                     c("vaxdate6_fix",sum(concordant$vaxdate6_fix==checkDate,na.rm=T))))
names(vaxdate_check_table)<-c("Variable","N \"check\" dates")

# output as a formatted table:
kable(vaxdate_check_table,booktabs=T,align="lc") %>%
    row_spec(as.numeric(row.names(vaxdate_check_table)[vaxdate_check_table$`N "check" dates` > 0]),background="#ffeda0") %>% # color row yellow if any check dates
    column_spec(1:2,width="1in")


```

$~$

The "original" and "fixed" values should be identical.

```{r qc_fix_agreement, include=TRUE}
# print("original")
# table(concordant$dose_agree, useNA = "ifany")
# 
# print("fixed")
# table(concordant$dose_agree_fix, useNA = "ifany") # should be same as above table

# check if the date breakdowns match, and make it an indicator variable:
dose_agree_check_text<-ifelse(table(concordant$dose_agree, useNA = "ifany")==table(concordant$dose_agree_fix, useNA = "ifany"),"Match","Don't match")

# Make a simple table showing the # matches for the original and fixed dates and the indicator created above
dose_agree_check<-as.data.frame(cbind(c(sum(concordant$dose_agree==1,na.rm=T)),c(sum(concordant$dose_agree==1,na.rm=T)),c(dose_agree_check_text)))
# set the column names
names(dose_agree_check)<-c("Original count of vax doses matching vax dates","Count of \"fixed\" vax doses matching vax dates","Check")

# output as a simple formatted table, with conditional coloring for the rows
kable(dose_agree_check,booktabs=T,align="c") %>%
  row_spec(1,background=ifelse(dose_agree_check$Check=="Match","#a1d99b","#fc9272")) %>% # color row green if passed check
  column_spec(1:2,width="2in")
```

## Check 7

Cases with any out-of-order dates are excluded.

```{r documentation_outoforder}
# now identify how many cases have at least one date entered out of chronologic order
nonChron <- 
  concordant %>% 
  filter(((vaxdate2_fix < vaxdate1_fix) | (vaxdate3_fix < vaxdate1_fix) | (vaxdate4_fix < vaxdate1_fix) | (vaxdate5_fix < vaxdate1_fix) |  (vaxdate6_fix < vaxdate1_fix) |
            (vaxdate3_fix < vaxdate2_fix) | (vaxdate4_fix < vaxdate2_fix) | (vaxdate5_fix < vaxdate2_fix) | (vaxdate6_fix < vaxdate2_fix) |
            (vaxdate4_fix < vaxdate3_fix) | (vaxdate5_fix < vaxdate3_fix) | (vaxdate6_fix < vaxdate3_fix) |
            (vaxdate5_fix < vaxdate4_fix) | (vaxdate6_fix < vaxdate4_fix)|
            (vaxdate6_fix < vaxdate5_fix))) 

# filter out cases where dates are out of order
concordantOrdered <- concordant %>% filter(!master_id %in% nonChron$master_id)

```

This month, `r nrow(nonChron)` cases are excluded from `r jurisdiction`'s case data because at least one date recorded for the second, third, fourth, or fifth vaccine date chronologically comes before a date recorded in a previous vaccine date.

## Minimum Intervals
As a data cleaning step, we are imposing minimum intervals between vaccine doses for 1) the primary series to first booster, and 2) first to second booster. For this analysis, we are imposing a minimum interval of >=56 days between the primary series and first booster and between the first and second boosters for all vaccine products.


```{r minimum_interval_bd1}
# Setting the minimum interval between the primary series and first booster dose
# Will create a series of new variables with "_minint1" for each recorded dose, i.e.: vaxdate1_minint1, vaxmfr1_minint1, vaxdate2_minint1, vaxmfr2_minint1, etc
# split each into sections for 6mo-4years versus the other age groups

# create a variable for age at first vaccine dose to help assign vaccine status
concordant_minint <- concordantOrdered %>% 
  mutate(age_at_vaxdose1 = floor(as.duration(interval(dob, vaxdate1_fix)) / dyears()))

# fix the age_at_vaxdose1 for NC same as for the primary age var
concordant_minint$age_at_vaxdose1[is.na(as.numeric(concordant_minint$age) - as.numeric(concordant_minint$age_at_vaxdose1))==F &  (as.numeric(concordant_minint$age) - as.numeric(concordant_minint$age_at_vaxdose1)) > 99] <- as.numeric(concordant_minint$age)


concordant_minint <- concordant_minint %>% 
  mutate(
    # Dose 1
    vaxdate1_minint1 = vaxdate1_fix, # vax dose 1 can always stay the same
    vaxmfr1_minint1 = vaxmfr1_fix,
    
    # Dose 2
    vaxdate2_minint1 = case_when( 
      is.na(vaxdate2_fix) ~ NA_Date_, 
      # Note: because of how we've already cleaned above, we know that if there is an entry for vaxdate2_fix, there is also an available vaxdate1_fix, so no need to check for NAs further
      age_at_vaxdose1<5 ~ vaxdate2_fix,
      # if first dose was J&J (coded as "4"), then need to make sure the second dose (i.e. first booster) is at least 56 days later, otherwise stays the same
      vaxmfr1_fix=="4" & (vaxdate2_fix - vaxdate1_fix) < 56 ~ NA_Date_,
      TRUE ~ vaxdate2_fix),
    
    vaxmfr2_minint1 = case_when(
      is.na(vaxdate2_fix) ~ NA_character_,
      age_at_vaxdose1<5 ~ vaxmfr2_fix,
      vaxmfr1_fix=="4" & (vaxdate2_fix - vaxdate1_fix) < 56 ~ NA_character_,
      TRUE ~ vaxmfr2_fix),
    
    # Dose 3
    vaxdate3_minint1 = case_when( 
      is.na(vaxdate3_fix) ~ NA_Date_,
      # Note: because of how we've already cleaned above, we know that if there is an entry for vaxdate3_fix, there is also an available vaxdate1_fix & vaxdate2_fix, so no need to check for NAs further in those variables
      
      age_at_vaxdose1<5 ~ vaxdate3_fix,
      
      # if the first dose was J&J, then need to make sure all the following doses are at least 56 days later
      vaxmfr1_fix=="4" & (vaxdate3_fix - vaxdate1_fix) < 56 ~ NA_Date_, 
      # if the second dose was J&J and therefore determined the primary series, then need to check following doses are at least 56 days later
      vaxmfr2_fix=="4" & (vaxdate3_fix - vaxdate2_fix) < 56 ~ NA_Date_,
      # if any other vaccine in 2nd slot, need following doses to be at least 56 days later. 
      # Note: Could remove the step above specifying J&J as the dose 2 product since this step will account for that, but leaving it in for now for clarity.
      vaxdate3_fix - vaxdate2_fix < 56 ~ NA_Date_,
      TRUE ~ vaxdate3_fix),
     
     vaxmfr3_minint1 = case_when( 
      is.na(vaxdate3_fix) ~ NA_character_,
      
      age_at_vaxdose1<5 ~ vaxmfr3_fix,
      
      # if first dose was J&J, then need to make sure all the following doses are at least 56 days later
      vaxmfr1_fix=="4" & (vaxdate3_fix - vaxdate1_fix) < 56 ~ NA_character_, 
      # if second dose was J&J and therefore that determined the primary series, then need to check following doses are at least 56 days later
      vaxmfr2_fix=="4" & (vaxdate3_fix - vaxdate2_fix) < 56 ~ NA_character_,
      # if any other vaccine in 2nd slot, need following doses to be at least 120 days later
      vaxdate3_fix - vaxdate2_fix < 56 ~ NA_character_,
      TRUE ~ vaxmfr3_fix),
    
    # Dose 4
     vaxdate4_minint1 = case_when( 
      is.na(vaxdate4_fix) ~ NA_Date_,
      
      age_at_vaxdose1<5 ~ vaxdate4_fix,
      
      # if first dose was J&J, then need to make sure all the following doses are at least 56 days later
      vaxmfr1_fix=="4" & (vaxdate4_fix - vaxdate1_fix) < 56 ~ NA_Date_, 
      # if second dose was J&J and therefore that determined the primary series, then need to check following doses are at least 56 days later
      vaxmfr2_fix=="4" & (vaxdate4_fix - vaxdate2_fix) < 56 ~ NA_Date_,
      # if any other vaccine in 2nd slot, need following doses to be at least 56 days later
      vaxdate4_fix - vaxdate2_fix < 56 ~ NA_Date_,
      TRUE ~ vaxdate4_fix),
    
     vaxmfr4_minint1 = case_when( 
      is.na(vaxdate4_fix) ~ NA_character_,
      
      age_at_vaxdose1<5 ~ vaxmfr4_fix,
      
      # if first dose was J&J, then need to make sure all the following doses are at least 56 days later
      vaxmfr1_fix=="4" & (vaxdate4_fix - vaxdate1_fix) < 56 ~ NA_character_, 
      # if second dose was J&J and therefore that determined the primary series, then need to check following doses are at least 56 days later
      vaxmfr2_fix=="4" & (vaxdate4_fix - vaxdate2_fix) < 56 ~ NA_character_,
      # if any other vaccine in 2nd slot, need following doses to be at least 56 days later
      vaxdate4_fix - vaxdate2_fix < 56 ~ NA_character_,
      TRUE ~ vaxmfr4_fix),
    
    # Dose 5
     vaxdate5_minint1 = case_when( 
      is.na(vaxdate5_fix) ~ NA_Date_,
      
      age_at_vaxdose1<5 ~ vaxdate5_fix,
      
      # if first dose was J&J, then need to make sure all the following doses are at least 56 days later
      vaxmfr1_fix=="4" & (vaxdate5_fix - vaxdate1_fix) < 56 ~ NA_Date_, 
      # if second dose was J&J and therefore that determined the primary series, then need to check following doses are at least 56 days later
      vaxmfr2_fix=="4" & (vaxdate5_fix - vaxdate2_fix) < 56 ~ NA_Date_,
      # if any other vaccine in 2nd slot, need following doses to be at least 56 days later
      vaxdate5_fix - vaxdate2_fix < 56 ~ NA_Date_,
      TRUE ~ vaxdate5_fix),
    
     vaxmfr5_minint1 = case_when( 
      is.na(vaxdate5_fix) ~ NA_character_,
      
      age_at_vaxdose1<5 ~ vaxmfr5_fix,
      
      # if first dose was J&J, then need to make sure all the following doses are at least 56 days later
      vaxmfr1_fix=="4" & (vaxdate5_fix - vaxdate1_fix) < 56 ~ NA_character_, 
      # if second dose was J&J and therefore that determined the primary series, then need to check following doses are at least 56 days later
      vaxmfr2_fix=="4" & (vaxdate5_fix - vaxdate2_fix) < 56 ~ NA_character_,
      # if any other vaccine in 2nd slot, need following doses to be at least 56 days later
      vaxdate5_fix - vaxdate2_fix < 56 ~ NA_character_,
      TRUE ~ vaxmfr5_fix),
    
    # Dose 6
     vaxdate6_minint1 = case_when( 
      is.na(vaxdate6_fix) ~ NA_Date_,
      
      age_at_vaxdose1<5 ~ vaxdate6_fix,
      
      # if first dose was J&J, then need to make sure all the following doses are at least 56 days later
      vaxmfr1_fix=="4" & (vaxdate6_fix - vaxdate1_fix) < 56 ~ NA_Date_, 
      # if second dose was J&J and therefore that determined the primary series, then need to check following doses are at least 56 days later
      vaxmfr2_fix=="4" & (vaxdate6_fix - vaxdate2_fix) < 56 ~ NA_Date_,
      # if any other vaccine in 2nd slot, need following doses to be at least 56 days later
      vaxdate6_fix - vaxdate2_fix < 56 ~ NA_Date_,
      TRUE ~ vaxdate6_fix),
    
     vaxmfr6_minint1 = case_when( 
      is.na(vaxdate6_fix) ~ NA_character_,
      
      age_at_vaxdose1<5 ~ vaxmfr6_fix,
      
      # if first dose was J&J, then need to make sure all the following doses are at least 56 days later
      vaxmfr1_fix=="4" & (vaxdate6_fix - vaxdate1_fix) < 56 ~ NA_character_, 
      # if second dose was J&J and therefore that determined the primary series, then need to check following doses are at least 56 days later
      vaxmfr2_fix=="4" & (vaxdate6_fix - vaxdate2_fix) < 56 ~ NA_character_,
      # if any other vaccine in 2nd slot, need following doses to be at least 56 days later
      vaxdate6_fix - vaxdate2_fix < 56 ~ NA_character_,
      TRUE ~ vaxmfr6_fix)
    
    )

# Next, run code to condense the new dose  variables, eliminating any set to NA. 
# Then repeat this process for second boosters, then run the condensing code one last time.
```

After removing the doses identified above as not meeting the minimum interval between primary series doses, summary of vaccine doses removed due to not meeting the minimum interval criteria for primary series to first booster:

```{r minint1_check, include=T}
# add a simple table to check how many doses were affected by setting a minimum interval for primary series to booster 1:
minint1_check_table<-concordant_minint %>%
  summarize(dose2=paste0(format(sum(is.na(vaxdate2_fix)==F & is.na(vaxdate2_minint1)),big.mark=",")," (",round((sum(is.na(vaxdate2_fix)==F & is.na(vaxdate2_minint1))/sum(is.na(vaxdate2_fix)==F))*100,1),"%)"),
            dose3=paste0(format(sum(is.na(vaxdate3_fix)==F & is.na(vaxdate3_minint1)),big.mark=",")," (",round((sum(is.na(vaxdate3_fix)==F & is.na(vaxdate3_minint1))/sum(is.na(vaxdate3_fix)==F))*100,1),"%)"),
            dose4=paste0(format(sum(is.na(vaxdate4_fix)==F & is.na(vaxdate4_minint1)),big.mark=",")," (",round((sum(is.na(vaxdate4_fix)==F & is.na(vaxdate4_minint1))/sum(is.na(vaxdate4_fix)==F))*100,1),"%)"),
            dose5=paste0(format(sum(is.na(vaxdate5_fix)==F & is.na(vaxdate5_minint1)),big.mark=",")," (",round((sum(is.na(vaxdate5_fix)==F & is.na(vaxdate5_minint1))/sum(is.na(vaxdate5_fix)==F))*100,1),"%)"),
            dose6=paste0(format(sum(is.na(vaxdate6_fix)==F & is.na(vaxdate6_minint1)),big.mark=",")," (",round((sum(is.na(vaxdate6_fix)==F & is.na(vaxdate6_minint1))/sum(is.na(vaxdate6_fix)==F))*100,1),"%)"))

# set nicer column headers with the sample sizes:
colnames(minint1_check_table)<-c(paste0("Dose 2 (n=",format(sum(is.na(concordant_minint$vaxdate2_fix)==F),big.mark=","),")"),
                                 paste0("Dose 3 (n=",format(sum(is.na(concordant_minint$vaxdate3_fix)==F),big.mark=","),")"),
                                 paste0("Dose 4 (n=",format(sum(is.na(concordant_minint$vaxdate4_fix)==F),big.mark=","),")"),
                                 paste0("Dose 5 (n=",format(sum(is.na(concordant_minint$vaxdate5_fix)==F),big.mark=","),")"),
                                 paste0("Dose 6 (n=",format(sum(is.na(concordant_minint$vaxdate6_fix)==F),big.mark=","),")"))

# pivot longer:
minint1_check_table<-pivot_longer(minint1_check_table,cols=1:5,names_to="Dose",values_to="n (%) removed")

# output nicely:
kable(minint1_check_table, booktabs=T,align="lr") %>%
  row_spec(0,align="c")
```


```{r fix_skipped_minint_bd1}
# Run the same code as above for correcting skipped vaccine dose entries (which we will have created by removing those outside of the minimal interval) 
# First, make a variable for a comma-separated list of the non-missing vaccine dose variables for date and mfr:
concordant_minint<-concordant_minint %>%
  mutate(vaxdate_minint1_condense = paste(ifelse(is.na(vaxdate1_minint1)==F,as.character(vaxdate1_minint1),"Missing"),
                                  ifelse(is.na(vaxdate2_minint1)==F,as.character(vaxdate2_minint1),"Missing"),
                                  ifelse(is.na(vaxdate3_minint1)==F,as.character(vaxdate3_minint1),"Missing"),
                                  ifelse(is.na(vaxdate4_minint1)==F,as.character(vaxdate4_minint1),"Missing"),
                                  ifelse(is.na(vaxdate5_minint1)==F,as.character(vaxdate5_minint1),"Missing"),
                                  ifelse(is.na(vaxdate6_minint1)==F,as.character(vaxdate6_minint1),"Missing"),sep=","),
         vaxmfr_minint1_condense = paste(ifelse(is.na(vaxmfr1_minint1)==F,vaxmfr1_minint1,"Missing"),
                                  ifelse(is.na(vaxmfr2_minint1)==F,vaxmfr2_minint1,"Missing"),
                                  ifelse(is.na(vaxmfr3_minint1)==F,vaxmfr3_minint1,"Missing"),
                                  ifelse(is.na(vaxmfr4_minint1)==F,vaxmfr4_minint1,"Missing"),
                                  ifelse(is.na(vaxmfr5_minint1)==F,vaxmfr5_minint1,"Missing"),
                                  ifelse(is.na(vaxmfr6_minint1)==F,vaxmfr6_minint1,"Missing"),sep=","))

# Then, replace all the instances of "Missing" as they appear in the list. Note the order followed below is important! 
# The first two steps for each variable remove "Missing"s in the list in any slot (the second step is for when they appear as the very first dose in particular, noting comma placement)
# The third step is for when all doses are Missing - step one will leave it so all that is left is "Missing" without the comma, and for whatever reason it wasn't working to replace this with a blank space so these will be replaced with NA, which works with the rest of the code
concordant_minint$vaxdate_minint1_condense <- gsub(",Missing","",concordant_minint$vaxdate_minint1_condense)
concordant_minint$vaxdate_minint1_condense <- gsub("Missing,","",concordant_minint$vaxdate_minint1_condense)
concordant_minint$vaxdate_minint1_condense <- gsub("Missing",NA,concordant_minint$vaxdate_minint1_condense)
concordant_minint$vaxmfr_minint1_condense <- gsub(",Missing","",concordant_minint$vaxmfr_minint1_condense)
concordant_minint$vaxmfr_minint1_condense <- gsub("Missing,","",concordant_minint$vaxmfr_minint1_condense)
concordant_minint$vaxmfr_minint1_condense <- gsub("Missing",NA,concordant_minint$vaxmfr_minint1_condense)

# then can reference this list by index to make a set of new "fixed" variables
concordant_minint<-concordant_minint %>% 
  mutate(vaxdate1_minint1_fix = lapply(vaxdate_minint1_condense, function(x) strsplit(x,",")[[1]][1]),
         vaxdate2_minint1_fix = lapply(vaxdate_minint1_condense, function(x) strsplit(x,",")[[1]][2]),
         vaxdate3_minint1_fix = lapply(vaxdate_minint1_condense, function(x) strsplit(x,",")[[1]][3]),
         vaxdate4_minint1_fix = lapply(vaxdate_minint1_condense, function(x) strsplit(x,",")[[1]][4]),
         vaxdate5_minint1_fix = lapply(vaxdate_minint1_condense, function(x) strsplit(x,",")[[1]][5]),
         vaxdate6_minint1_fix = lapply(vaxdate_minint1_condense, function(x) strsplit(x,",")[[1]][6]),
         vaxmfr1_minint1_fix = lapply(vaxmfr_minint1_condense, function(x) strsplit(x,",")[[1]][1]),
         vaxmfr2_minint1_fix = lapply(vaxmfr_minint1_condense, function(x) strsplit(x,",")[[1]][2]),
         vaxmfr3_minint1_fix = lapply(vaxmfr_minint1_condense, function(x) strsplit(x,",")[[1]][3]),
         vaxmfr4_minint1_fix = lapply(vaxmfr_minint1_condense, function(x) strsplit(x,",")[[1]][4]),
         vaxmfr5_minint1_fix = lapply(vaxmfr_minint1_condense, function(x) strsplit(x,",")[[1]][5]),
         vaxmfr6_minint1_fix = lapply(vaxmfr_minint1_condense, function(x) strsplit(x,",")[[1]][6]) )

# convert all back to dates or characters from list type (does not work to include this as one function within lapply, for some reason...)
concordant_minint<-concordant_minint %>% 
  mutate(vaxdate1_minint1_fix = as.Date(as.character(vaxdate1_minint1_fix)),
         vaxdate2_minint1_fix = as.Date(as.character(vaxdate2_minint1_fix)),
         vaxdate3_minint1_fix = as.Date(as.character(vaxdate3_minint1_fix)),
         vaxdate4_minint1_fix = as.Date(as.character(vaxdate4_minint1_fix)),
         vaxdate5_minint1_fix = as.Date(as.character(vaxdate5_minint1_fix)),
         vaxdate6_minint1_fix = as.Date(as.character(vaxdate6_minint1_fix)),
         vaxmfr1_minint1_fix = as.character(vaxmfr1_minint1_fix),
         vaxmfr2_minint1_fix = as.character(vaxmfr2_minint1_fix),
         vaxmfr3_minint1_fix = as.character(vaxmfr3_minint1_fix),
         vaxmfr4_minint1_fix = as.character(vaxmfr4_minint1_fix),
         vaxmfr5_minint1_fix = as.character(vaxmfr5_minint1_fix),
         vaxmfr6_minint1_fix = as.character(vaxmfr6_minint1_fix) )

concordant_minint <- concordant_minint %>% 
   mutate(
    vaxCourse_minint1_fix = paste(vaxmfr1_minint1_fix, vaxmfr2_minint1_fix, vaxmfr3_minint1_fix, vaxmfr4_minint1_fix, vaxmfr5_minint1_fix, vaxmfr6_minint1_fix, sep = "/"), 
    dateSeq_minint1_fix = paste(t.f(vaxdate1_minint1_fix), t.f(vaxdate2_minint1_fix), t.f(vaxdate3_minint1_fix), t.f(vaxdate4_minint1_fix), t.f(vaxdate5_minint1_fix),t.f(vaxdate6_minint1_fix), sep = "/"), 
    mfrSeq_minint1_fix = paste(t.f(vaxmfr1_minint1_fix), t.f(vaxmfr2_minint1_fix), t.f(vaxmfr3_minint1_fix), t.f(vaxmfr4_minint1_fix), t.f(vaxmfr5_minint1_fix),t.f(vaxmfr6_minint1_fix), sep = "/"), 
    dose_agree_minint1_fix = if_else(dateSeq_minint1_fix == mfrSeq_minint1_fix, "1", "0"))

```



```{r minimum_interval_bd2}
# Check interval between first and second booster
# For any vaccine type, 56 days between first and second booster

concordant_minint <- concordant_minint %>% 
  mutate(
    # Dose 1
    vaxdate1_minint2 = vaxdate1_minint1_fix, # vax dose 1 can always stay the same
    vaxmfr1_minint2 = vaxmfr1_minint1_fix, 
    
    # Dose 2
    vaxdate2_minint2 =  vaxdate2_minint1_fix,# vax dose 2 can always stay the same
    vaxmfr2_minint2 = vaxmfr2_minint1_fix,
    
    # Dose 3
    vaxdate3_minint2 = case_when(
      is.na(vaxdate3_minint1_fix) ~ NA_Date_,
      
      age_at_vaxdose1<5 ~ vaxdate3_minint1_fix,
      
      # if first dose was J&J, then need to make sure all doses following first booster (dose 2) are at least 56 days after
      vaxmfr1_minint1_fix=="4" & (vaxdate3_minint1_fix - vaxdate2_minint1_fix) < 56 ~ NA_Date_, 
      TRUE ~ vaxdate3_minint1_fix),
    
    vaxmfr3_minint2 = case_when(
      is.na(vaxdate3_minint1_fix) ~ NA_character_,
      
      age_at_vaxdose1<5 ~ vaxmfr3_minint1_fix,
      
      # if first dose was J&J, then need to make sure all doses following first booster (dose 2) are at least 56 days after
      vaxmfr1_minint1_fix=="4" & (vaxdate3_minint1_fix - vaxdate2_minint1_fix) < 56 ~ NA_character_, 
      TRUE ~ vaxmfr3_minint1_fix),
    
    # Dose 4
     vaxdate4_minint2 = case_when( 
      is.na(vaxdate4_minint1_fix) ~ NA_Date_,
      
      age_at_vaxdose1<5 ~ vaxdate4_minint1_fix,
      
       # if first dose was J&J, then need to make sure all doses following first booster (dose 2) are at least 56 days after
      vaxmfr1_minint1_fix=="4" & (vaxdate4_minint1_fix - vaxdate2_minint1_fix) < 56 ~ NA_Date_, 
      # if second dose was J&J and therefore that determined the primary series, then need to check following doses after dose 3 (first booster) are at least 56 days later
      vaxmfr2_minint1_fix=="4" & (vaxdate4_minint1_fix - vaxdate3_minint1_fix) < 56 ~ NA_Date_,
      # if any other vaccine besides J&J used for primary series, need doses following the 3rd dose to be at least 56 days later
      vaxdate4_minint1_fix - vaxdate3_minint1_fix < 56 ~ NA_Date_,
      TRUE ~ vaxdate4_minint1_fix),
    
     vaxmfr4_minint2 = case_when( 
      is.na(vaxdate4_minint1_fix) ~ NA_character_,
      
      age_at_vaxdose1<5 ~ vaxmfr4_minint1_fix,
      
       # if first dose was J&J, then need to make sure all doses following first booster (dose 2) are at least 56 days after
      vaxmfr1_minint1_fix=="4" & (vaxdate4_minint1_fix - vaxdate2_minint1_fix) < 56 ~ NA_character_, 
      # if second dose was J&J and therefore that determined the primary series, then need to check following doses after dose 3 (first booster) are at least 56 days later
      vaxmfr2_minint1_fix=="4" & (vaxdate4_minint1_fix - vaxdate3_minint1_fix) < 56 ~ NA_character_,
      # if any other vaccine besides J&J used for primary series, need doses following the 3rd dose to be at least 56 days later
      vaxdate4_minint1_fix - vaxdate3_minint1_fix < 56 ~ NA_character_,
      TRUE ~ vaxmfr4_minint1_fix),
    
    # Dose 5
     vaxdate5_minint2 = case_when( 
      is.na(vaxdate5_minint1_fix) ~ NA_Date_,
      
      age_at_vaxdose1<5 ~ vaxdate5_minint1_fix,
      
       # if first dose was J&J, then need to make sure all doses following first booster (dose 2) are at least 56 days after
      vaxmfr1_minint1_fix=="4" & (vaxdate5_minint1_fix - vaxdate2_minint1_fix) < 56 ~ NA_Date_, 
      # if second dose was J&J and therefore that determined the primary series, then need to check following doses after dose 3 (first booster) are at least 56 days later
      vaxmfr2_minint1_fix=="4" & (vaxdate5_minint1_fix - vaxdate3_minint1_fix) < 56 ~ NA_Date_,
      # if any other vaccine besides J&J used for primary series, need doses following the 3rd dose to be at least 56 days later
      vaxdate5_minint1_fix - vaxdate3_minint1_fix < 56 ~ NA_Date_,
      TRUE ~ vaxdate5_minint1_fix),
    
     vaxmfr5_minint2 = case_when( 
      is.na(vaxdate5_minint1_fix) ~ NA_character_,
      
      age_at_vaxdose1<5 ~ vaxmfr5_minint1_fix,
      
       # if first dose was J&J, then need to make sure all doses following first booster (dose 2) are at least 56 days after
      vaxmfr1_minint1_fix=="4" & (vaxdate5_minint1_fix - vaxdate2_minint1_fix) < 56 ~ NA_character_, 
      # if second dose was J&J and therefore that determined the primary series, then need to check following doses after dose 3 (first booster) are at least 56 days later
      vaxmfr2_minint1_fix=="4" & (vaxdate5_minint1_fix - vaxdate3_minint1_fix) < 56 ~ NA_character_,
      # if any other vaccine besides J&J used for primary series, need doses following the 3rd dose to be at least 56 days later
      vaxdate5_minint1_fix - vaxdate3_minint1_fix < 56 ~ NA_character_,
      TRUE ~ vaxmfr5_minint1_fix),
    
    # Dose 6
     vaxdate6_minint2 = case_when( 
      is.na(vaxdate6_minint1_fix) ~ NA_Date_,
      
      age_at_vaxdose1<5 ~ vaxdate6_minint1_fix,
      
       # if first dose was J&J, then need to make sure all doses following first booster (dose 2) are at least 56 days after
      vaxmfr1_minint1_fix=="4" & (vaxdate6_minint1_fix - vaxdate2_minint1_fix) < 56 ~ NA_Date_, 
      # if second dose was J&J and therefore that determined the primary series, then need to check following doses after dose 3 (first booster) are at least 56 days later
      vaxmfr2_minint1_fix=="4" & (vaxdate6_minint1_fix - vaxdate3_minint1_fix) < 56 ~ NA_Date_,
      # if any other vaccine besides J&J used for primary series, need doses following the 3rd dose to be at least 56 days later
      vaxdate6_minint1_fix - vaxdate3_minint1_fix < 56 ~ NA_Date_,
      TRUE ~ vaxdate6_minint1_fix),
    
     vaxmfr6_minint2 = case_when( 
      is.na(vaxdate6_minint1_fix) ~ NA_character_,
      
      age_at_vaxdose1<5 ~ vaxmfr6_minint1_fix,
      
       # if first dose was J&J, then need to make sure all doses following first booster (dose 2) are at least 56 days after
      vaxmfr1_minint1_fix=="4" & (vaxdate6_minint1_fix - vaxdate2_minint1_fix) < 56 ~ NA_character_, 
      # if second dose was J&J and therefore that determined the primary series, then need to check following doses after dose 3 (first booster) are at least 56 days later
      vaxmfr2_minint1_fix=="4" & (vaxdate6_minint1_fix - vaxdate3_minint1_fix) < 56 ~ NA_character_,
      # if any other vaccine besides J&J used for primary series, need doses following the 3rd dose to be at least 56 days later
      vaxdate6_minint1_fix - vaxdate3_minint1_fix < 56 ~ NA_character_,
      TRUE ~ vaxmfr6_minint1_fix)
    )

```


After removing the doses identified above as not meeting the minimum interval between primary series and first booster, summary of vaccine doses removed due to not meeting the minimum interval criteria for the first to second booster:

```{r minint2_check, include=T}
# add a simple table to check how many doses were affected by setting a minimum interval for first to second booster:
minint2_check_table<-concordant_minint %>%
  summarize(dose2=paste0(format(sum(is.na(vaxdate2_minint1_fix)==F & is.na(vaxdate2_minint2)),big.mark=",")," (",round((sum(is.na(vaxdate2_minint1_fix)==F & is.na(vaxdate2_minint2))/sum(is.na(vaxdate2_minint1_fix)==F))*100,1),"%)"),
            dose3=paste0(format(sum(is.na(vaxdate3_minint1_fix)==F & is.na(vaxdate3_minint2)),big.mark=",")," (",round((sum(is.na(vaxdate3_minint1_fix)==F & is.na(vaxdate3_minint2))/sum(is.na(vaxdate3_minint1_fix)==F))*100,1),"%)"),
            dose4=paste0(format(sum(is.na(vaxdate4_minint1_fix)==F & is.na(vaxdate4_minint2)),big.mark=",")," (",round((sum(is.na(vaxdate4_minint1_fix)==F & is.na(vaxdate4_minint2))/sum(is.na(vaxdate4_minint1_fix)==F))*100,1),"%)"),
            dose5=paste0(format(sum(is.na(vaxdate5_minint1_fix)==F & is.na(vaxdate5_minint2)),big.mark=",")," (",round((sum(is.na(vaxdate5_minint1_fix)==F & is.na(vaxdate5_minint2))/sum(is.na(vaxdate5_minint1_fix)==F))*100,1),"%)"),
            dose6=paste0(format(sum(is.na(vaxdate6_minint1_fix)==F & is.na(vaxdate6_minint2)),big.mark=",")," (",round((sum(is.na(vaxdate6_minint1_fix)==F & is.na(vaxdate6_minint2))/sum(is.na(vaxdate6_minint1_fix)==F))*100,1),"%)"))

# set nicer column headers with the sample sizes:
colnames(minint2_check_table)<-c(paste0("Dose 2 (n=",format(sum(is.na(concordant_minint$vaxdate2_minint1_fix)==F),big.mark=","),")"),
                                 paste0("Dose 3 (n=",format(sum(is.na(concordant_minint$vaxdate3_minint1_fix)==F),big.mark=","),")"),
                                 paste0("Dose 4 (n=",format(sum(is.na(concordant_minint$vaxdate4_minint1_fix)==F),big.mark=","),")"),
                                 paste0("Dose 5 (n=",format(sum(is.na(concordant_minint$vaxdate5_minint1_fix)==F),big.mark=","),")"),
                                 paste0("Dose 6 (n=",format(sum(is.na(concordant_minint$vaxdate6_minint1_fix)==F),big.mark=","),")"))

# pivot longer:
minint2_check_table<-pivot_longer(minint2_check_table,cols=1:5,names_to="Dose",values_to="n (%) removed")

# output nicely:
kable(minint2_check_table, booktabs=T,align="lr") %>%
  row_spec(0,align="c")
```


```{r fix_skipped_minint_bd2}
# Run the same code as above for correcting skipped vaccine dose entries (which we will have again created by removing those outside of the minimal interval for second boosters) one more time to set the final vaccine status

# First, make a variable for a comma-separated list of the non-missing vaccine dose variables for date and mfr:
# insert "missing" if the variable is NA
concordant_minint<-concordant_minint %>%
  mutate(vaxdate_minint2_condense = paste(ifelse(is.na(vaxdate1_minint2)==F,as.character(vaxdate1_minint2),"Missing"),
                                  ifelse(is.na(vaxdate2_minint2)==F,as.character(vaxdate2_minint2),"Missing"),
                                  ifelse(is.na(vaxdate3_minint2)==F,as.character(vaxdate3_minint2),"Missing"),
                                  ifelse(is.na(vaxdate4_minint2)==F,as.character(vaxdate4_minint2),"Missing"),
                                  ifelse(is.na(vaxdate5_minint2)==F,as.character(vaxdate5_minint2),"Missing"),
                                  ifelse(is.na(vaxdate6_minint2)==F,as.character(vaxdate6_minint2),"Missing"),sep=","),
         vaxmfr_minint2_condense = paste(ifelse(is.na(vaxmfr1_minint2)==F,vaxmfr1_minint2,"Missing"),
                                  ifelse(is.na(vaxmfr2_minint2)==F,vaxmfr2_minint2,"Missing"),
                                  ifelse(is.na(vaxmfr3_minint2)==F,vaxmfr3_minint2,"Missing"),
                                  ifelse(is.na(vaxmfr4_minint2)==F,vaxmfr4_minint2,"Missing"),
                                  ifelse(is.na(vaxmfr5_minint2)==F,vaxmfr5_minint2,"Missing"),
                                  ifelse(is.na(vaxmfr6_minint2)==F,vaxmfr6_minint2,"Missing"),sep=","))

# Then, replace all the instances of "Missing" as they appear in the list. Note the order followed below is important! 
# The first two steps for each variable remove "Missing"s in the list in any slot (the second step is for when they appear as the very first dose in particular, noting comma placement)
# The third step is for when all doses are Missing - step one will leave it so all that is left is "Missing" without the comma, and for whatever reason it wasn't working to replace this with a blank space so these will be replaced with NA, which works with the rest of the code
concordant_minint$vaxdate_minint2_condense <- gsub(",Missing","",concordant_minint$vaxdate_minint2_condense)
concordant_minint$vaxdate_minint2_condense <- gsub("Missing,","",concordant_minint$vaxdate_minint2_condense)
concordant_minint$vaxdate_minint2_condense <- gsub("Missing",NA,concordant_minint$vaxdate_minint2_condense)
concordant_minint$vaxmfr_minint2_condense <- gsub(",Missing","",concordant_minint$vaxmfr_minint2_condense)
concordant_minint$vaxmfr_minint2_condense <- gsub("Missing,","",concordant_minint$vaxmfr_minint2_condense)
concordant_minint$vaxmfr_minint2_condense <- gsub("Missing",NA,concordant_minint$vaxmfr_minint2_condense)

# then can reference this list by index to make a set of new "fixed" variables
concordant_minint<-concordant_minint %>% 
  mutate(vaxdate1_minint2_fix = lapply(vaxdate_minint2_condense, function(x) strsplit(x,",")[[1]][1]),
         vaxdate2_minint2_fix = lapply(vaxdate_minint2_condense, function(x) strsplit(x,",")[[1]][2]),
         vaxdate3_minint2_fix = lapply(vaxdate_minint2_condense, function(x) strsplit(x,",")[[1]][3]),
         vaxdate4_minint2_fix = lapply(vaxdate_minint2_condense, function(x) strsplit(x,",")[[1]][4]),
         vaxdate5_minint2_fix = lapply(vaxdate_minint2_condense, function(x) strsplit(x,",")[[1]][5]),
         vaxdate6_minint2_fix = lapply(vaxdate_minint2_condense, function(x) strsplit(x,",")[[1]][6]),
         vaxmfr1_minint2_fix = lapply(vaxmfr_minint2_condense, function(x) strsplit(x,",")[[1]][1]),
         vaxmfr2_minint2_fix = lapply(vaxmfr_minint2_condense, function(x) strsplit(x,",")[[1]][2]),
         vaxmfr3_minint2_fix = lapply(vaxmfr_minint2_condense, function(x) strsplit(x,",")[[1]][3]),
         vaxmfr4_minint2_fix = lapply(vaxmfr_minint2_condense, function(x) strsplit(x,",")[[1]][4]),
         vaxmfr5_minint2_fix = lapply(vaxmfr_minint2_condense, function(x) strsplit(x,",")[[1]][5]),
         vaxmfr6_minint2_fix = lapply(vaxmfr_minint2_condense, function(x) strsplit(x,",")[[1]][6]) )

# convert all back to dates or characters from list type (does not work to include this as one function within lapply, for some reason...)
concordant_minint<-concordant_minint %>% 
  mutate(vaxdate1_minint2_fix = as.Date(as.character(vaxdate1_minint2_fix)),
         vaxdate2_minint2_fix = as.Date(as.character(vaxdate2_minint2_fix)),
         vaxdate3_minint2_fix = as.Date(as.character(vaxdate3_minint2_fix)),
         vaxdate4_minint2_fix = as.Date(as.character(vaxdate4_minint2_fix)),
         vaxdate5_minint2_fix = as.Date(as.character(vaxdate5_minint2_fix)),
         vaxdate6_minint2_fix = as.Date(as.character(vaxdate6_minint2_fix)),
         vaxmfr1_minint2_fix = as.character(vaxmfr1_minint2_fix),
         vaxmfr2_minint2_fix = as.character(vaxmfr2_minint2_fix),
         vaxmfr3_minint2_fix = as.character(vaxmfr3_minint2_fix),
         vaxmfr4_minint2_fix = as.character(vaxmfr4_minint2_fix),
         vaxmfr5_minint2_fix = as.character(vaxmfr5_minint2_fix),
         vaxmfr6_minint2_fix = as.character(vaxmfr6_minint2_fix) )



concordant_minint <- concordant_minint %>% 
   mutate(
    vaxCourse_minint2_fix = paste(vaxmfr1_minint2_fix, vaxmfr2_minint2_fix, vaxmfr3_minint2_fix, vaxmfr4_minint2_fix, vaxmfr5_minint2_fix, vaxmfr6_minint2_fix, sep = "/"), 
    dateSeq_minint2_fix = paste(t.f(vaxdate1_minint2_fix), t.f(vaxdate2_minint2_fix), t.f(vaxdate3_minint2_fix), t.f(vaxdate4_minint2_fix), t.f(vaxdate5_minint2_fix),t.f(vaxdate6_minint2_fix), sep = "/"), 
    mfrSeq_minint2_fix = paste(t.f(vaxmfr1_minint2_fix), t.f(vaxmfr2_minint2_fix), t.f(vaxmfr3_minint2_fix), t.f(vaxmfr4_minint2_fix), t.f(vaxmfr5_minint2_fix),t.f(vaxmfr6_minint2_fix), sep = "/"), 
    dose_agree_minint2_fix = if_else(dateSeq_minint2_fix == mfrSeq_minint2_fix, "1", "0"))

```

```{r assign_dose}
# figure out which original dose was ultimately used for each dose in the series that we'll count
concordant_minint <- concordant_minint%>%
  mutate(final_vaxmfr1 = case_when(vaxdate1_minint2_fix==vaxdate1 ~ vaxmfr1_rc,
                                 vaxdate1_minint2_fix==vaxdate2 ~ vaxmfr2_rc,
                                 vaxdate1_minint2_fix==vaxdate3 ~ vaxmfr3_rc,
                                 vaxdate1_minint2_fix==vaxdate4 ~ vaxmfr4_rc,
                                 vaxdate1_minint2_fix==vaxdate5 ~ vaxmfr5_rc,
                                 vaxdate1_minint2_fix==vaxdate6 ~ vaxmfr6_rc,
                                 T ~ NA_character_),
         final_vaxmfr2 = case_when(vaxdate2_minint2_fix==vaxdate2 ~ vaxmfr2_rc,
                                 vaxdate2_minint2_fix==vaxdate3 ~ vaxmfr3_rc,
                                 vaxdate2_minint2_fix==vaxdate4 ~ vaxmfr4_rc,
                                 vaxdate2_minint2_fix==vaxdate5 ~ vaxmfr5_rc,
                                 vaxdate2_minint2_fix==vaxdate6 ~ vaxmfr6_rc,
                                 T ~ NA_character_),
         final_vaxmfr3 = case_when(vaxdate3_minint2_fix==vaxdate3 ~ vaxmfr3_rc,
                                 vaxdate3_minint2_fix==vaxdate4 ~ vaxmfr4_rc,
                                 vaxdate3_minint2_fix==vaxdate5 ~ vaxmfr5_rc,
                                 vaxdate3_minint2_fix==vaxdate6 ~ vaxmfr6_rc,
                                 T ~ NA_character_),
         final_vaxmfr4 = case_when(vaxdate4_minint2_fix==vaxdate4 ~ vaxmfr4_rc,
                                 vaxdate4_minint2_fix==vaxdate5 ~ vaxmfr5_rc,
                                 vaxdate4_minint2_fix==vaxdate6 ~ vaxmfr6_rc,
                                 T ~ NA_character_),
         final_vaxmfr5 = case_when(vaxdate5_minint2_fix==vaxdate5 ~ vaxmfr5_rc,
                                 vaxdate5_minint2_fix==vaxdate6 ~ vaxmfr6_rc,
                                 T ~ NA_character_),
         final_vaxmfr6 = case_when(vaxdate6_minint2_fix==vaxdate6 ~ vaxmfr6_rc,
                                 T ~ NA_character_))
# moving forward we should be able to use this logic and can remove the vaxmfr variables from the minimum interval steps to save a little time. Could even remove the vaxmfr variables from the other cleaning steps before that, but they are used in various output checks so that would be more of a pain. Can use this same logic to assign the final vaxtype (CVX) variables when they start coming in.

# interim fix for vaxtype variable name until we see how other jurs submit it:
names(concordant_minint)[names(concordant_minint)=="vrvac_covid19_type1"]<-"vaxtype1"
names(concordant_minint)[names(concordant_minint)=="vrvac_covid19_type2"]<-"vaxtype2"
names(concordant_minint)[names(concordant_minint)=="vrvac_covid19_type3"]<-"vaxtype3"
names(concordant_minint)[names(concordant_minint)=="vrvac_covid19_type4"]<-"vaxtype4"
names(concordant_minint)[names(concordant_minint)=="vrvac_covid19_type5"]<-"vaxtype5"
names(concordant_minint)[names(concordant_minint)=="vrvac_covid19_type6"]<-"vaxtype6"

concordant_minint <- concordant_minint%>%
  mutate(final_vaxtype1 = case_when(vaxdate1_minint2_fix==vaxdate1 ~ vaxtype1,
                                 vaxdate1_minint2_fix==vaxdate2 ~ vaxtype2,
                                 vaxdate1_minint2_fix==vaxdate3 ~ vaxtype3,
                                 vaxdate1_minint2_fix==vaxdate4 ~ vaxtype4,
                                 vaxdate1_minint2_fix==vaxdate5 ~ vaxtype5,
                                 vaxdate1_minint2_fix==vaxdate6 ~ vaxtype6,
                                 T ~ NA_character_),
         final_vaxtype2 = case_when(vaxdate2_minint2_fix==vaxdate2 ~ vaxtype2,
                                 vaxdate2_minint2_fix==vaxdate3 ~ vaxtype3,
                                 vaxdate2_minint2_fix==vaxdate4 ~ vaxtype4,
                                 vaxdate2_minint2_fix==vaxdate5 ~ vaxtype5,
                                 vaxdate2_minint2_fix==vaxdate6 ~ vaxtype6,
                                 T ~ NA_character_),
         final_vaxtype3 = case_when(vaxdate3_minint2_fix==vaxdate3 ~ vaxtype3,
                                 vaxdate3_minint2_fix==vaxdate4 ~ vaxtype4,
                                 vaxdate3_minint2_fix==vaxdate5 ~ vaxtype5,
                                 vaxdate3_minint2_fix==vaxdate6 ~ vaxtype6,
                                 T ~ NA_character_),
         final_vaxtype4 = case_when(vaxdate4_minint2_fix==vaxdate4 ~ vaxtype4,
                                 vaxdate4_minint2_fix==vaxdate5 ~ vaxtype5,
                                 vaxdate4_minint2_fix==vaxdate6 ~ vaxtype6,
                                 T ~ NA_character_),
         final_vaxtype5 = case_when(vaxdate5_minint2_fix==vaxdate5 ~ vaxtype5,
                                 vaxdate5_minint2_fix==vaxdate6 ~ vaxtype6,
                                 T ~ NA_character_),
         final_vaxtype6 = case_when(vaxdate6_minint2_fix==vaxdate6 ~ vaxtype6,
                                 T ~ NA_character_))


```



# Vaccine Product, Key Vaccination Dates, and Boosters

## Primary Series Vaccine Product

We'll next create a variable identifying the vaccine product of the primary vaccine series. This variable is only specified as a specific manufacturer for cases that have completed a full primary series (two doses of Pfizer, Moderna, or Unknown vaccine manufacturers or one dose of Janssen). Individuals with Otherwise, this variable is specified as "Partial" or "Unvaccinated" without differentiating a manufacturer. For individuals 6 months to 4 years old, the vaccine product is determined considering the first 3 doses, as the Pfizer primary series for this age group uses 3 doses.

Below is a table of the different combinations of vaccine manufacturers in dose 1 and 2 slots, along with their ultimate vaccine product classification, for cases where every vaccine manufacturer entry has a date and vice versa for individuals who were at least 5 years old at the time of their first COVID-19 vaccination. This also provides documentation of how many cases are excluded for receiving two doses of a non-FDA product (*vax_prod* = "Non-FDA").

```{r vax_prod, include=TRUE}
firstTwo <- function(x) {substr(x, 1, 3)}
firstThree <- function(x) {substr(x, 1, 5)}

concordantProduct <- 
  concordant_minint %>% 
  mutate(vax_prod = case_when(
        is.na(final_vaxmfr1) ~ "Unvaccinated", # after all the automated wrangling, a blank first mfr means that they don't have any doses entered

    # assign the 6mo-4 age group first (@ first vax dose) since they can have 3 doses as primary series
    age_at_vaxdose1 < 5 & firstTwo(vaxCourse_minint2_fix) %in% c("2/2","9/2") ~ "Moderna",
    age_at_vaxdose1 < 5 & firstTwo(vaxCourse_minint2_fix) %in% c("2/9","9/9") ~ "Unknown", # UPDATE: assume these are two dose complete

    
    age_at_vaxdose1 < 5 & firstThree(vaxCourse_minint2_fix) %in% c("2/1/2","1/2/2","1/1/2","9/1/2","1/9/2") ~ "Moderna",
    age_at_vaxdose1 < 5 & firstThree(vaxCourse_minint2_fix) %in% c("1/1/1", "1/2/1", "2/1/1", "9/1/1", "1/9/1") ~ "Pfizer",
    age_at_vaxdose1 < 5 & firstThree(vaxCourse_minint2_fix) %in% c("1/2/9","2/1/9","1/9/9","9/1/9","1/1/9") ~ "Unknown",
    age_at_vaxdose1 < 5 & firstTwo(vaxCourse_minint2_fix) %in% c("1/N","2/N","9/N") ~ "Partial" ,
    age_at_vaxdose1 < 5 & firstThree(vaxCourse_minint2_fix) %in% c("1/1/N","1/2/N","2/1/N","1/9/N","9/1/N")~ "Partial",
    # then if any of the first 3 doses is a non-FDA approved product (including J&J for <5s), mark Non-FDA (note - we are now removing non-FDA above, so the only ones that should show up here are J&J)
    age_at_vaxdose1 < 5 & (!(final_vaxmfr1 %in% c("1","2","9")) | !(final_vaxmfr2 %in% c("1","2","9")) | !(final_vaxmfr3 %in% c("1","2","9"))) ~ "Non-FDA",
    age_at_vaxdose1 < 5 ~ "Check",
    
    # then do all other age groups:
    firstTwo(vaxCourse_minint2_fix) %in% c("1/1", "2/1", "9/1") ~ "Pfizer",
    firstTwo(vaxCourse_minint2_fix) %in% c("1/2", "2/2", "9/2") ~ "Moderna",
    firstTwo(vaxCourse_minint2_fix) %in% c("1/9", "2/9", "9/9") ~ "Unknown", 
    firstTwo(vaxCourse_minint2_fix) %in% c("1/N", "2/N", "9/N") ~ "Partial", 
    final_vaxmfr1 == "4" | final_vaxmfr2 == "4" ~ "Janssen", 
    final_vaxmfr1 == "5" | final_vaxmfr2 == "5" ~ "Non-FDA", # evaluation of case_when means Janssen gets priority; so if no Janssen entered and a non-FDA vaccine is in either 1st or 2nd position, then these individuals wouldn't be fully vaccinated with FDA-authorized vaccines
    TRUE ~ "Check"))


combos_5plus <- 
  concordantProduct %>% 
  filter(age_at_vaxdose1>=5) %>%
  group_by(vax_prod, final_vaxmfr1, final_vaxmfr2) %>%
  tally() 

#print(combos, n=nrow(combos)) # converted this to a formatted table below

# note if any alarmingly large numbers of partial or unvax product assignments, which may require follow-up with jurisdictions

# LRL note: ^ could be a good place for a flag, if there is a particular threshold we want to use

# make a formatted table to show this output, and add conditional formatting for row that correspond to non-FDA/partial/unvax
kable(combos_5plus,booktabs=T,align="lccr") %>%
    row_spec(as.numeric(row.names(combos_5plus)[combos_5plus$vax_prod %in% c("Non-FDA","Partial","Unvaccinated")]),background="#ffeda0") %>% # color row yellow if will be removed
    column_spec(1:3,width="1in")

n_vax_history_exclude<-sum(concordantProduct$vax_prod %in% c("Partial", "Unvaccinated", "Non-FDA"))
# exclude cases where only their vaccine history information indicates they can never be considered fully vaccinated
concordantDates <- concordantProduct %>% filter(!vax_prod %in% c("Partial", "Unvaccinated", "Non-FDA"))

```

Below is a table of the different combinations of vaccine manufacturers in dose 1, 2, and 3 slots, along with their ultimate vaccine product classification, for cases where every vaccine manufacturer entry has a date and vice versa for individuals who were under 5 years old at the time of their first COVID-19 vaccination.

```{r vax_prod_under5, include=TRUE}
# add a table to show the under 5s at vax dose 1 specifically
combos_under5 <- 
  concordantProduct %>% 
  filter(age_at_vaxdose1<5) %>%
  group_by(vax_prod, final_vaxmfr1, final_vaxmfr2,final_vaxmfr3) %>%
  tally() 

# make a formatted table to show this output, and add conditional formatting for row that correspond to non-FDA/partial/unvax
kable(combos_under5,booktabs=T,align="lcccr") %>%
    row_spec(as.numeric(row.names(combos_under5)[combos_under5$vax_prod %in% c("Non-FDA","Partial","Unvaccinated")]),background="#ffeda0") %>% # color row yellow if will be removed
    column_spec(1:4,width="1in")

```


## Key Vaccination Dates

Dates for the first FDA-authorized dose, the first FDA-authorized dose in a primary series, the second dose in a primary series, and additional doses beyond the primary series are created behind the scenes.

```{r date_creation}
# now create dates to use for evaluation of timing of positive test relative to vaccine series completion
concordantDates <- 
  concordantDates %>% 
  mutate(
    vax_first_dt = case_when(
      vax_prod == "Unvaccinated" ~ NA_Date_, # Unvaccinated always have no vaccine doses
      
      age_at_vaxdose1 < 5 ~ vaxdate1_minint2_fix,
      
      # partially vax could have 1st FDA dose in 1st or 2nd slot
      # Note we've updated code to remove the non-FDA doses, so this should no longer be happening
      vax_prod == "Partial" & final_vaxmfr1 == "5" ~ vaxdate2_minint2_fix, 
      vax_prod == "Partial" & final_vaxmfr1 != "5" ~ vaxdate1_minint2_fix, 
      
      # non-Janssen product all have first date as vaxdate1_minint2_fix because we excluded out-of-order cases
      vax_prod %in% c("Pfizer", "Moderna", "Unknown") ~ vaxdate1_minint2_fix, 
      
      # Janssen products could have received a dose before the Janssen dose
      vax_prod == "Janssen" & final_vaxmfr1 == "5" ~ vaxdate2_minint2_fix, # if first dose was AZ, use the second JJ dose as the first dose
      vax_prod == "Janssen" & final_vaxmfr1!= "5" ~ vaxdate1_minint2_fix, 
      
      TRUE ~ checkDate), # indicator for if a combination of products/vaxmfr1/vaxmfr2 isn't accounted for
    
    # variable for start date of primary series; same as vax_first_date except when Janssen received in the second slot
    vax_start_dt = case_when(
      vax_prod == "Janssen" & final_vaxmfr1 != "4" ~ vaxdate2_minint2_fix, 
      TRUE ~ vax_first_dt), 
    
    # date of completion of primary series 
    vax_compl_dt = case_when(
      vax_prod %in% c("Unvaccinated", "Partial") ~ NA_Date_, # no completion date
      vax_prod == "Janssen" ~ vax_start_dt, # because only one dose
      
      # if under 5 and vax prod is pfizer, or moderna/unknown but one of the first 2 doses was a pfizer, use the 3rd dose
      age_at_vaxdose1 < 5 & (vax_prod =="Pfizer" | final_vaxmfr1=="1" | final_vaxmfr2=="1") ~ vaxdate3_minint2_fix,

      # otherwise, would be the second dose
      vax_prod %in% c("Pfizer", "Moderna", "Unknown") ~ vaxdate2_minint2_fix,
      TRUE ~ checkDate), 
    
    # this is the first date that the individual is considered fully vaccinated
    fully_vax_dt = vax_compl_dt + days(14), 
    
    # identifying dates of additional/booster doses
    vax_booster_dt1 = case_when(
      vax_prod %in% c("Unvaccinated", "Partial") ~ NA_Date_, 
      
      # if <5, this is theoretical for now since these aren't authorized, but would be the 4th dose unless first 2 are moderna or a mix of moderna/unknown
      age_at_vaxdose1 < 5 & vax_compl_dt==vaxdate3_minint2_fix ~ vaxdate4_minint2_fix, 
      age_at_vaxdose1 < 5 & vax_compl_dt==vaxdate2_minint2_fix ~ vaxdate3_minint2_fix, 
      age_at_vaxdose1 < 5 ~ checkDate,
      
      # since out-of-order dates excluded, must be vaxdate3_minint2_fix for all 2-dose series as long as it's an fda-approved vaccine
      vax_prod %in% c("Pfizer", "Moderna", "Unknown") & 
        (final_vaxmfr3 == "5" | is.na(final_vaxmfr3)) ~ NA_Date_, 
      vax_prod %in% c("Pfizer", "Moderna", "Unknown") & final_vaxmfr3 != "5"~ vaxdate3_minint2_fix, 
      
      # since out-of-order dates excluded, must be vaxdate2_minint2_fix for Janssen if in first slot
      vax_prod == "Janssen" & final_vaxmfr1 == "4" & 
        (final_vaxmfr2 == "5" | is.na(final_vaxmfr2)) ~ NA_Date_, 
      vax_prod == "Janssen" & final_vaxmfr1 == "4" & final_vaxmfr2 != "5" ~ vaxdate2_minint2_fix, 
      
      # for the cases where Janssen in second slot determined product type
      vax_prod == "Janssen" & final_vaxmfr2 == "4" & 
        (final_vaxmfr3 == "5" | is.na(final_vaxmfr3)) ~ NA_Date_, 
      vax_prod == "Janssen" & final_vaxmfr2 == "4" & final_vaxmfr3 != "5" ~ vaxdate3_minint2_fix, 
      
      TRUE ~ checkDate),
    
    # identifying the manufacturer of an additional booster dose; follow same logic as vax_booster_dt1 creation but grab mfr instead of date
    vax_booster_mfr1 = case_when(
      vax_prod %in% c("Unvaccinated", "Partial") ~ NA_character_, 
      
      # if <5, this is theoretical for now since these aren't authorized, but would be the 4th dose unless first 2 are moderna
      age_at_vaxdose1 < 5 & vax_compl_dt==vaxdate3_minint2_fix ~ vaxmfr4_minint2_fix, 
      age_at_vaxdose1 < 5 & vax_compl_dt==vaxdate2_minint2_fix ~ vaxmfr3_minint2_fix, 
      age_at_vaxdose1 < 5 ~ "check",

      vax_prod %in% c("Pfizer", "Moderna", "Unknown") & 
        (vaxmfr3_minint2_fix == "5" | is.na(vaxmfr3_minint2_fix)) ~ NA_character_, 
      vax_prod %in% c("Pfizer", "Moderna", "Unknown") & vaxmfr3_minint2_fix != "5" ~ vaxmfr3_minint2_fix, 
      
      vax_prod == "Janssen" & vaxmfr1_minint2_fix == "4" & 
        (vaxmfr2_minint2_fix == "5" | is.na(vaxmfr2_minint2_fix)) ~ NA_character_, 
      vax_prod == "Janssen" & vaxmfr1_minint2_fix == "4" & vaxmfr2_minint2_fix != "5" ~ vaxmfr2_minint2_fix, 
      
      vax_prod == "Janssen" & vaxmfr2_minint2_fix == "4" & 
        (vaxmfr3_minint2_fix == "5" | is.na(vaxmfr3_minint2_fix)) ~ NA_character_, 
      vax_prod == "Janssen" & vaxmfr2_minint2_fix == "4" & vaxmfr3_minint2_fix != "5" ~ vaxmfr3_minint2_fix, 
      TRUE ~ "check"), 
     #----------------------------------- 
    # identifying another date of an additional booster dose, since some have four entries and we're using a date cutoff only
    # LRL update: this section was already here but looked copied form the vax_booster_dt1 above, just updated to use the correct dates
    vax_booster_dt2 = case_when(
      vax_prod %in% c("Unvaccinated", "Partial") ~ NA_Date_,
      
      # if <5, this is theoretical for now since these aren't authorized, but would be the 5th dose unless first 2 are moderna
      age_at_vaxdose1 < 5 & vax_compl_dt==vaxdate3_minint2_fix ~ vaxdate5_minint2_fix, 
      age_at_vaxdose1 < 5 & vax_compl_dt==vaxdate2_minint2_fix ~ vaxdate4_minint2_fix, 
      age_at_vaxdose1 < 5 ~ checkDate,
      
      # since out-of-order dates excluded, must be vaxdate4_minint2_fix for all 2-dose series as long as it's an fda-approved vaccine
      vax_prod %in% c("Pfizer", "Moderna", "Unknown") & 
        (vaxmfr4_minint2_fix == "5" | is.na(vaxmfr4_minint2_fix)) ~ NA_Date_, 
      vax_prod %in% c("Pfizer", "Moderna", "Unknown") & vaxmfr4_minint2_fix != "5"~ vaxdate4_minint2_fix, 
      
      # since out-of-order dates excluded, must be vaxdate3_minint2_fix for Janssen if in first slot
      vax_prod == "Janssen" & vaxmfr1_minint2_fix == "4" & 
        (vaxmfr3_minint2_fix == "5" | is.na(vaxmfr3_minint2_fix)) ~ NA_Date_, 
      vax_prod == "Janssen" & vaxmfr1_minint2_fix == "4" & vaxmfr3_minint2_fix != "5" ~ vaxdate3_minint2_fix, 
      
      # for the cases where Janssen in second slot determined product type
      vax_prod == "Janssen" & vaxmfr2_minint2_fix == "4" & 
        (vaxmfr4_minint2_fix == "5" | is.na(vaxmfr4_minint2_fix)) ~ NA_Date_, 
      vax_prod == "Janssen" & vaxmfr2_minint2_fix == "4" & vaxmfr4_minint2_fix != "5" ~ vaxdate4_minint2_fix, 
      
      TRUE ~ checkDate), 
    
    # identifying mfr of another possible date of an additional booster dose; follow same logic as vax_booster_dt2 creation but grab mfr instead of date
    vax_booster_mfr2 = case_when(
      vax_prod %in% c("Unvaccinated", "Partial") ~ NA_character_, 
      
      # if <5, this is theoretical for now since these aren't authorized, but would be the 5th dose unless first 2 are moderna
      age_at_vaxdose1 < 5 & vax_compl_dt==vaxdate3_minint2_fix ~ vaxmfr5_minint2_fix, 
      age_at_vaxdose1 < 5 & vax_compl_dt==vaxdate2_minint2_fix ~ vaxmfr4_minint2_fix, 
      age_at_vaxdose1 < 5 ~ "check",
      
      vax_prod %in% c("Pfizer", "Moderna", "Unknown") & 
        (vaxmfr4_minint2_fix == "5" | is.na(vaxmfr4_minint2_fix)) ~ NA_character_, 
      vax_prod %in% c("Pfizer", "Moderna", "Unknown") & vaxmfr4_minint2_fix != "5" ~ vaxmfr4_minint2_fix, 
      
      vax_prod == "Janssen" & vaxmfr1_minint2_fix == "4" & 
        (vaxmfr3_minint2_fix == "5" | is.na(vaxmfr3_minint2_fix)) ~ NA_character_, 
      vax_prod == "Janssen" & vaxmfr1_minint2_fix == "4" & vaxmfr3_minint2_fix != "5" ~ vaxmfr3_minint2_fix, 
      
      # since out-of-order dates excluded, must be vaxdate4_minint2_fix for Janssen if Janssen is in first slot and 4th dose isn't a non-FDA vaccine
      vax_prod == "Janssen" &  vaxmfr2_minint2_fix == "4" & 
        (vaxmfr4_minint2_fix == "5" | is.na(vaxmfr4_minint2_fix)) ~ NA_character_, 
      vax_prod == "Janssen" & vaxmfr2_minint2_fix == "4" & vaxmfr4_minint2_fix != "5" ~ vaxmfr4_minint2_fix, 
      TRUE ~ "check"),
  #-----------------------------------  
    # LRL note: adding another date of an additional booster dose, since some have five entries and we're using a date cutoff only
    vax_booster_dt3 = case_when(
      vax_prod %in% c("Unvaccinated", "Partial") ~ NA_Date_,
      
       # if <5, this is theoretical for now since these aren't authorized, but would be the 6th dose unless first 2 are moderna
      age_at_vaxdose1 < 5 & vax_compl_dt==vaxdate3_minint2_fix ~ vaxdate6_minint2_fix, 
      age_at_vaxdose1 < 5 & vax_compl_dt==vaxdate2_minint2_fix ~ vaxdate5_minint2_fix, 
      age_at_vaxdose1 < 5 ~ checkDate,
      
      # since out-of-order dates excluded, must be vaxdate5_minint2_fix for all 2-dose series as long as it's an fda-approved vaccine
      vax_prod %in% c("Pfizer", "Moderna", "Unknown") & 
        (vaxmfr5_minint2_fix == "5" | is.na(vaxmfr5_minint2_fix)) ~ NA_Date_, 
      vax_prod %in% c("Pfizer", "Moderna", "Unknown") & vaxmfr5_minint2_fix != "5"~ vaxdate5_minint2_fix, 
      
      # since out-of-order dates excluded, must be vaxdate4_minint2_fix for Janssen if in first slot
      vax_prod == "Janssen" & vaxmfr1_minint2_fix == "4" & 
        (vaxmfr4_minint2_fix == "5" | is.na(vaxmfr4_minint2_fix)) ~ NA_Date_, 
      vax_prod == "Janssen" & vaxmfr1_minint2_fix == "4" & vaxmfr4_minint2_fix != "5" ~ vaxdate4_minint2_fix, 
      
      # for the cases where Janssen in second slot determined product type
      vax_prod == "Janssen" & vaxmfr2_minint2_fix == "4" & 
        (vaxmfr5_minint2_fix == "5" | is.na(vaxmfr5_minint2_fix)) ~ NA_Date_, 
      vax_prod == "Janssen" & vaxmfr2_minint2_fix == "4" & vaxmfr5_minint2_fix != "5" ~ vaxdate5_minint2_fix, 
      
      TRUE ~ checkDate), 
  
    vax_booster_mfr3 = case_when(
      vax_prod %in% c("Unvaccinated", "Partial") ~ NA_character_, 
      
      # if <5, this is theoretical for now since these aren't authorized, but would be the 6th dose unless first 2 are moderna
      age_at_vaxdose1 < 5 & vax_compl_dt==vaxdate3_minint2_fix ~ vaxmfr6_minint2_fix, 
      age_at_vaxdose1 < 5 & vax_compl_dt==vaxdate2_minint2_fix ~ vaxmfr5_minint2_fix, 
      age_at_vaxdose1 < 5 ~ "check",
      
      # since out-of-order dates excluded, must be vaxdate5_minint2_fix for all 2-dose series as long as it's an fda-approved vaccine
      vax_prod %in% c("Pfizer", "Moderna", "Unknown") & 
        (vaxmfr5_minint2_fix == "5" | is.na(vaxmfr5_minint2_fix)) ~ NA_character_, 
      vax_prod %in% c("Pfizer", "Moderna", "Unknown") & vaxmfr5_minint2_fix != "5"~ vaxmfr5_minint2_fix, 
      
      # since out-of-order dates excluded, must be vaxdate4_minint2_fix for Janssen if in first slot
      vax_prod == "Janssen" & vaxmfr1_minint2_fix == "4" & 
        (vaxmfr4_minint2_fix == "5" | is.na(vaxmfr4_minint2_fix)) ~ NA_character_, 
      vax_prod == "Janssen" & vaxmfr1_minint2_fix == "4" & vaxmfr4_minint2_fix != "5" ~ vaxmfr4_minint2_fix, 
      
      # for the cases where Janssen in second slot determined product type
      vax_prod == "Janssen" & vaxmfr2_minint2_fix == "4" & 
        (vaxmfr5_minint2_fix == "5" | is.na(vaxmfr5_minint2_fix)) ~ NA_character_, 
      vax_prod == "Janssen" & vaxmfr2_minint2_fix == "4" & vaxmfr5_minint2_fix != "5" ~ vaxmfr5_minint2_fix, 
      
      TRUE ~ "check"),
  
     #----------------------------------- 
    # LRL note: and adding one more date of an additional booster dose, since we're going to collect up to 6 doses starting June 2022
    vax_booster_dt4 = case_when(
      vax_prod %in% c("Unvaccinated", "Partial") ~ NA_Date_,
      
      # for now, don't include the <5s at all this many doses out
       age_at_vaxdose1 < 5 ~ NA_Date_,
      
      # since out-of-order dates excluded, must be vaxdate6_minint2_fix for all 2-dose series as long as it's an fda-approved vaccine
      vax_prod %in% c("Pfizer", "Moderna", "Unknown") & 
        (vaxmfr6_minint2_fix == "5" | is.na(vaxmfr6_minint2_fix)) ~ NA_Date_, 
      vax_prod %in% c("Pfizer", "Moderna", "Unknown") & vaxmfr6_minint2_fix != "5"~ vaxdate6_minint2_fix, 
      
      # since out-of-order dates excluded, must be vaxdate5_minint2_fix for Janssen if in first slot
      vax_prod == "Janssen" & vaxmfr1_minint2_fix == "4" & 
        (vaxmfr5_minint2_fix == "5" | is.na(vaxmfr5_minint2_fix)) ~ NA_Date_, 
      vax_prod == "Janssen" & vaxmfr1_minint2_fix == "4" & vaxmfr5_minint2_fix != "5" ~ vaxdate5_minint2_fix, 
      
      # for the cases where Janssen in second slot determined product type
      vax_prod == "Janssen" & vaxmfr2_minint2_fix == "4" & 
        (vaxmfr6_minint2_fix == "5" | is.na(vaxmfr6_minint2_fix)) ~ NA_Date_, 
      vax_prod == "Janssen" & vaxmfr2_minint2_fix == "4" & vaxmfr6_minint2_fix != "5" ~ vaxdate6_minint2_fix, 
      
      TRUE ~ checkDate), 
     
    vax_booster_mfr4 = case_when(
      vax_prod %in% c("Unvaccinated", "Partial") ~ NA_character_,
      
      # for now, don't include the <5s at all this many doses out
       age_at_vaxdose1 < 5 ~ NA_character_,
      
      # since out-of-order dates excluded, must be vaxdate6_minint2_fix for all 2-dose series as long as it's an fda-approved vaccine
      vax_prod %in% c("Pfizer", "Moderna", "Unknown") & 
        (vaxmfr6_minint2_fix == "5" | is.na(vaxmfr6_minint2_fix)) ~ NA_character_, 
      vax_prod %in% c("Pfizer", "Moderna", "Unknown") & vaxmfr6_minint2_fix != "5" ~ vaxmfr6_minint2_fix, 
      
      # since out-of-order dates excluded, must be vaxdate5_minint2_fix for Janssen if in first slot
      vax_prod == "Janssen" & vaxmfr1_minint2_fix == "4" & 
        (vaxmfr5_minint2_fix == "5" | is.na(vaxmfr5_minint2_fix)) ~ NA_character_, 
      vax_prod == "Janssen" & vaxmfr1_minint2_fix == "4" & vaxmfr5_minint2_fix != "5" ~ vaxmfr5_minint2_fix, 
      
      # for the cases where Janssen in second slot determined product type
      vax_prod == "Janssen" & vaxmfr2_minint2_fix == "4" & 
        (vaxmfr6_minint2_fix == "5" | is.na(vaxmfr6_minint2_fix)) ~ NA_character_, 
      vax_prod == "Janssen" & vaxmfr2_minint2_fix == "4" & vaxmfr6_minint2_fix != "5" ~ vaxmfr6_minint2_fix, 
      
      TRUE ~ "check"), 
  #----------------------------------- 
    # LRL note: and adding even one more date of an additional booster dose just for J&J, since I found one in AZ who had J&J as their first dose and had five doses that needs this check!
    vax_booster_dt5 = case_when(
      vax_prod %in% c("Unvaccinated", "Partial","Moderna","Pfizer","Unknown") ~ NA_Date_, # would need to be a 7th dose for a 2-dose starter series, and we don't have that info available
      
      # for now, don't include the <5s at all this many doses out
       age_at_vaxdose1 < 5 ~ NA_Date_,
      
      # since out-of-order dates excluded, must be vaxdate6_minint2_fix for Janssen if in first slot
      vax_prod == "Janssen" & vaxmfr1_minint2_fix == "4" & 
        (vaxmfr6_minint2_fix == "5" | is.na(vaxmfr6_minint2_fix)) ~ NA_Date_, 
      vax_prod == "Janssen" & vaxmfr1_minint2_fix == "4" & vaxmfr5_minint2_fix != "5" ~ vaxdate6_minint2_fix, 
      
      TRUE ~ checkDate),
  
  vax_booster_mfr5 = case_when(
      vax_prod %in% c("Unvaccinated", "Partial","Moderna","Pfizer","Unknown") ~ NA_character_, 
      
      # for now, don't include the <5s at all this many doses out
       age_at_vaxdose1 < 5 ~ NA_character_,
      
      vax_prod == "Janssen" & vaxmfr1_minint2_fix == "4" & 
        (vaxmfr6_minint2_fix == "5" | is.na(vaxmfr6_minint2_fix)) ~ NA_character_,
      
      vax_prod == "Janssen" & vaxmfr1_minint2_fix == "4" & vaxmfr5_minint2_fix != "5" ~ vaxmfr6_minint2_fix,
      TRUE ~ "check"),
    
   #----------------------------------- 
    fully_boosted_dt = case_when(
      is.na(vax_booster_dt1) ~ NA_Date_, 
    
      # using 14 days after booster dose date to indicate start of when someone is classed as a boosted case; this is part of the working definition and subject to change
      vax_booster_dt1 >= boosterAuthDate ~ vax_booster_dt1 + days(14), 
    
      # if vax_booster_dt1 < boosterAuthDate and no vax_booster_dt2, then NA
      is.na(vax_booster_dt2)  ~ NA_Date_,
      
      # if vax_booster_dt1 < boosterAuthDate but vax_booster_dt2 >= boosterAuthDate, then vax_booster_dt2 +14
      vax_booster_dt2 >= boosterAuthDate ~ vax_booster_dt2 + days(14),
      
      # if vax_booster_dt1 < boosterAuthDate and vax_booster_dt2 < boosterAuthDate and no vax_booster_dt3, then NA
      is.na(vax_booster_dt3) ~ NA_Date_,
      
      # add check for if vax_booster_dt1 and vax_booster_dt2 are both before boosterAuthDate but they have a third dose (expect this to affect very very few people if any)
      # if vax_booster_dt3 >= boosterAuthDate, then vax_booster_dt3 +14
      vax_booster_dt3 >= boosterAuthDate ~ vax_booster_dt3 + days(14),
      
      # vax_booster_dt3<boosterAuthDate and no vax_booster_dt4
      is.na(vax_booster_dt4) ~ NA_Date_,
      
      vax_booster_dt4 >= boosterAuthDate ~ vax_booster_dt4 + days(14),
     
      TRUE ~ checkDate),
    
      # identifying mfr associated with fully_boosted_dt; follow same logic as fully_boosted_dt creation but grab mfr instead of date
    fully_boosted_mfr = case_when(
      is.na(vax_booster_dt1) ~ NA_character_, 
      vax_booster_dt1 >= boosterAuthDate ~ vax_booster_mfr1,
      is.na(vax_booster_dt2) ~ NA_character_, 
      vax_booster_dt2 >= boosterAuthDate ~ vax_booster_mfr2,
      is.na(vax_booster_dt3) ~ NA_character_, 
      vax_booster_dt3 >= boosterAuthDate ~ vax_booster_mfr3,
      is.na(vax_booster_dt4) ~ NA_character_, 
      vax_booster_dt4 >= boosterAuthDate ~ vax_booster_mfr4,
      TRUE ~ "check" ),
    
  
    second_boosted_dt = case_when(
      is.na(fully_boosted_dt) ~ NA_Date_, # if not fully boosted, can't be second boosted
      is.na(vax_booster_dt2) ~ NA_Date_, # if no second booster dose available, can't be second boosted
      
      # can base the rest off the fully_boosted_dt variable:
      # note that implicitly, if they have a fully_boosted_dt that must be after boosterAuthDate, so subsequent doses must be too
      # if fully_boost_dt = vax_booster_dt1 +14, then second_boosted_dt would be vax_booster_dt2 +14
      # if fully_boost_dt = vax_booster_dt2 +14, then second_boosted_dt would be vax_booster_dt3 +14, if available, and so on
   
      fully_boosted_dt == vax_booster_dt1 + days(14) ~ vax_booster_dt2 + days(14),
      
      (fully_boosted_dt == vax_booster_dt2 + days(14)) & is.na(vax_booster_dt3) ~ NA_Date_,
      
      fully_boosted_dt == vax_booster_dt2 + days(14) ~ vax_booster_dt3 + days(14),
      
      (fully_boosted_dt == vax_booster_dt3 + days(14)) & is.na(vax_booster_dt4) ~ NA_Date_,
      
      fully_boosted_dt == vax_booster_dt3 + days(14) ~ vax_booster_dt4 + days(14),
      
      (fully_boosted_dt == vax_booster_dt4 + days(14)) & is.na(vax_booster_dt5) ~ NA_Date_,
      
      fully_boosted_dt == vax_booster_dt4 + days(14) ~ vax_booster_dt5 + days(14),
    
     TRUE ~ checkDate),
    
    second_boosted_mfr = case_when(
      is.na(fully_boosted_dt) ~ NA_character_, #if not fully boosted, can't be second boosted
      is.na(vax_booster_dt2) ~ NA_character_, # if no second booster dose available, can't be second boosted 
      fully_boosted_dt == vax_booster_dt1 + days(14) ~ vax_booster_mfr2,
      (fully_boosted_dt == vax_booster_dt2 + days(14)) & is.na(vax_booster_dt3) ~ NA_character_,
      fully_boosted_dt == vax_booster_dt2 + days(14) ~ vax_booster_mfr3,
      (fully_boosted_dt == vax_booster_dt3 + days(14)) & is.na(vax_booster_dt4) ~ NA_character_,
      fully_boosted_dt == vax_booster_dt3 + days(14) ~ vax_booster_mfr4,
      (fully_boosted_dt == vax_booster_dt4 + days(14)) & is.na(vax_booster_dt5) ~ NA_character_,
      fully_boosted_dt == vax_booster_dt4 + days(14) ~ vax_booster_mfr5,
      TRUE ~ "check")
    )


```

All dates should return FALSE or NA for the check if they equal the specified "check" date. If N "check" date > 0 for any variable in the table below, code associated with that date variable needs to be revised. If N "check" date > 0 for any variable pertaining to boosters, code associated with that date variable and the corresponding manufacturer coding both need to be revised.

```{r qc_vaxdates, include=TRUE}
# check for the "check" indicator date; should all be FALSE or NA for each variable
#lapply(concordantDates %>% select(vax_first_dt, vax_start_dt, vax_compl_dt, fully_vax_dt, vax_booster_dt1, vax_booster_dt2, fully_boosted_dt), function(x) {table(x == checkDate, useNA = "ifany")}) 

# make this a table with conditional formatting instead
check_date_table<-as.data.frame(rbind(c("vax_first_dt",sum(concordantDates$vax_first_dt==checkDate,na.rm=T)),
                                     c("vax_start_dt",sum(concordantDates$vax_start_dt==checkDate,na.rm=T)),
                                     c("vax_compl_dt",sum(concordantDates$vax_compl_dt==checkDate,na.rm=T)),
                                     c("fully_vax_dt",sum(concordantDates$fully_vax_dt==checkDate,na.rm=T)),
                                     c("vax_booster_dt1",sum(concordantDates$vax_booster_dt1==checkDate,na.rm=T)),
                                     c("vax_booster_dt2",sum(concordantDates$vax_booster_dt2==checkDate,na.rm=T)),
                                     c("fully_boosted_dt",sum(concordantDates$fully_boosted_dt==checkDate,na.rm=T)),
                                     c("second_boosted_dt",sum(concordantDates$second_boosted_dt==checkDate,na.rm=T))))
names(check_date_table)<-c("Variable","N \"check\" dates")

# output as a formatted table:
kable(check_date_table,booktabs=T,align="lc") %>%
    row_spec(as.numeric(row.names(check_date_table)[check_date_table$`N "check" dates` > 0]),background="#ffeda0") %>% # color row yellow if any check dates
    column_spec(1:2,width="1in")

```

## Assignment of Vaccination Status

The final piece is assigning vaccination status at the time of the positive test. The created vaccine product type and vaccine-related dates are used in conjunction to assess vaccination status at the time of the positive test.

```{r status_when_positive}
concordantFinal <- 
  concordantDates %>% 
  # first creating the variable assigning vaccination status at the time of the positive test regardless of booster dose
  # reminder - we've already removed the cases with vaccine history such that they could not be considered fully vaccinated, so by this point in the code we know they have the vax dates referenced in this section
  mutate(vax_status = case_when(
    pos_test_date < (vax_first_dt + 14) ~ "Unvax", 
    pos_test_date >= (vax_first_dt + 14) & pos_test_date < fully_vax_dt ~ "Partial", 
    pos_test_date >= fully_vax_dt ~ "Fully", 
    TRUE ~ "check"), 
    
    # then creating the variable that differentiates between people with and without boosters
    # this doesn't consider whether or not a state is actually reporting boosters - that is addressed in the aggregation code
    vax_status_boost = case_when(
      vax_status != "Fully" ~ vax_status, # unvax and partial don't change
      vax_status == "Fully" & is.na(fully_boosted_dt) ~ vax_status, # those without boosters will stay in Fully category
      # if positive test less than 14 days before being fully boosted, still a fully vax case
      vax_status == "Fully" & fully_boosted_dt > pos_test_date ~ vax_status,
      vax_status == "Fully" & fully_boosted_dt <= pos_test_date ~ "Boosted", 
      # this coding works because the Aug 13 cutoff is built into whether or not a vax_boost_dt is even entered
      TRUE ~ "check"),
    
    # then creating a variable that differentiates between people with first and second boosters
    vax_status_second_boost = case_when(
      vax_status_boost != "Boosted" ~ vax_status, # unvax/partial/Fully shouldn't change
      vax_status_boost == "Boosted" & is.na(second_boosted_dt) ~ "First booster", # those without a second boosted dose classified as first booster
      # if positive test less than 14 days before being fully second boosted, still a first booster case
      vax_status_boost == "Boosted" & second_boosted_dt > pos_test_date ~ "First booster",
      vax_status_boost == "Boosted" & second_boosted_dt <= pos_test_date ~ "Second booster",
      TRUE ~ "check"
    ))

```

Note large numbers of partially vaccinated or unvaccinated cases, or identified with boosters for a jurisdiction that doesn't report boosters (should only occur for Janssen), and follow-up with jurisdictions as needed.

```{r qc_vaxstatus, include=TRUE}
#addmargins(table(concordantFinal$vax_status, concordantFinal$vax_prod, useNA = "ifany")) 
#addmargins(table(concordantFinal$vax_status_boost, concordantFinal$vax_prod, useNA = "ifany")) 

# LRL update: code above as a formatted table
vax_status_table<-as.data.frame(addmargins(table(concordantFinal$vax_status, concordantFinal$vax_prod, useNA = "ifany"))) 
# rework the table structure from long to wide:
vax_status_table<-pivot_wider(vax_status_table,names_from="Var2",values_from="Freq")
names(vax_status_table)[1]<-"Vax status"

vax_status_boost_table<-as.data.frame(addmargins(table(concordantFinal$vax_status_boost, concordantFinal$vax_prod, useNA = "ifany"))) 
# rework the table structure from long to wide:
vax_status_boost_table<-pivot_wider(vax_status_boost_table,names_from="Var2",values_from="Freq")
names(vax_status_boost_table)[1]<-"Vax status"

vax_status_second_boost_table<-as.data.frame(addmargins(table(concordantFinal$vax_status_second_boost, concordantFinal$vax_prod, useNA = "ifany"))) 
# rework the table structure from long to wide:
vax_status_second_boost_table<-pivot_wider(vax_status_second_boost_table,names_from="Var2",values_from="Freq")
names(vax_status_second_boost_table)[1]<-"Vax status"
# order by vax status
vax_status_second_boost_table$`Vax status`<-factor(vax_status_second_boost_table$`Vax status`,levels=c("Second booster","First booster","Fully","Partial","Unvax","Sum"))
vax_status_second_boost_table <- vax_status_second_boost_table %>% arrange(`Vax status`)

# output as a table with conditional formatting to highlight unexpected values
if(booster_reporter=="Yes" & second_booster_reporter=="Yes"){
kable(vax_status_second_boost_table,booktabs=T,align="lrrrrr") %>%
    row_spec(as.numeric(row.names(vax_status_second_boost_table)[vax_status_second_boost_table$`Vax status` %in% c("Partial","Unvax")]),background="#ffeda0") %>% # color row yellow if will be removed
    column_spec(2:ncol(vax_status_second_boost_table),width="1in") %>%
    column_spec(1,width="1.2in")}

if(booster_reporter=="Yes" & second_booster_reporter=="No"){
kable(vax_status_boost_table,booktabs=T,align="lrrrrr") %>%
    row_spec(as.numeric(row.names(vax_status_boost_table)[vax_status_boost_table$`Vax status` %in% c("Partial","Unvax")]),background="#ffeda0") %>% # color row yellow if will be removed
    column_spec(1:ncol(vax_status_boost_table),width="1in")}

# if this is a non-booster reporting jurisdiction, highlight any vax status that ended up classified as boosted?
if(booster_reporter=="No"){
  kable(vax_status_table,booktabs=T,align="lrrrrr") %>%
    row_spec(as.numeric(row.names(vax_status_table)[vax_status_table$`Vax status` %in% c("Partial","Unvax")]),background="#ffeda0") %>% # color row yellow if will be removed 
    row_spec(as.numeric(row.names(vax_status_table)[vax_status_table$`Vax status` %in% c("Boosted")]),background="#6baed6") %>%
    column_spec(1:ncol(vax_status_table),width="1in")
}

# Indicator variable to keep track of those that will be excluded from the final outputs
n_vax_dates_exclude<-sum(concordantFinal$vax_status %in% c("Unvax","Partial"))


#temporary <- concordantFinal %>% filter(vax_status == "Partial")
#temporary_output <- temporary[ , c('survey_id', 'local_id', 'vax_first_dt' , 'vax_start_dt', 'vax_compl_dt', 'fully_vax_dt', 'pos_test_date')]
#IDlist <- temporary_output[ , c('survey_id', 'local_id')]
#IDlist[is.na(IDlist)]=''
#write.csv(IDlist, file = paste0(qc_output_path, juris, "_PartialVaxIDs.csv"))

```

## Assignment of proposed new vaccination status (by vax prod of the most recent dose)

```{r new_vax_status, include=T}
# Add new vaccine status determinations based on the bivalent boosters
# Categories: unvaccinated, partially vaccinated, vaccinated without bivalent booster, vaccinated with bivalent booster

# first add variables for the final dose received and the manufacturer of that dose
# note - most recent dose received = most recent dose received at least 14 days before testing positive
concordantFinal <- concordantFinal %>%
  mutate(vaxdate_last_dose = case_when(is.na(vaxdate6_minint2_fix)==F & (pos_test_date - vaxdate6_minint2_fix) >= 14 ~ vaxdate6_minint2_fix,
                                           is.na(vaxdate5_minint2_fix)==F & (pos_test_date - vaxdate5_minint2_fix) >= 14 ~ vaxdate5_minint2_fix,
                                           is.na(vaxdate4_minint2_fix)==F & (pos_test_date - vaxdate4_minint2_fix) >= 14 ~ vaxdate4_minint2_fix,
                                           is.na(vaxdate3_minint2_fix)==F & (pos_test_date - vaxdate3_minint2_fix) >= 14 ~ vaxdate3_minint2_fix,
                                           is.na(vaxdate2_minint2_fix)==F & (pos_test_date - vaxdate2_minint2_fix) >= 14 ~ vaxdate2_minint2_fix,
                                           is.na(vaxdate1_minint2_fix)==F & (pos_test_date - vaxdate1_minint2_fix) >= 14 ~ vaxdate1_minint2_fix,
                                           TRUE ~ NA_Date_),
          vaxtype_last_dose = case_when(vaxdate_last_dose==vaxdate1_minint2_fix ~ final_vaxtype1,
                                        vaxdate_last_dose==vaxdate2_minint2_fix ~ final_vaxtype2,
                                        vaxdate_last_dose==vaxdate3_minint2_fix ~ final_vaxtype3,
                                        vaxdate_last_dose==vaxdate4_minint2_fix ~ final_vaxtype4,
                                        vaxdate_last_dose==vaxdate5_minint2_fix ~ final_vaxtype5,
                                        vaxdate_last_dose==vaxdate6_minint2_fix ~ final_vaxtype6,
                                        is.na(vaxdate_last_dose) ~ "check: unvax",
                                        TRUE ~ "Missing"),
         # replace any NAs for last dose type with "Missing" (as we know those must have have an associated date now)
         vaxtype_last_dose = ifelse(is.na(vaxtype_last_dose),"Missing",vaxtype_last_dose),
         
          vaxmfr_last_dose = case_when(vaxdate_last_dose==vaxdate1_minint2_fix ~ final_vaxmfr1,
                                       vaxdate_last_dose==vaxdate2_minint2_fix ~ final_vaxmfr2,
                                       vaxdate_last_dose==vaxdate3_minint2_fix ~ final_vaxmfr3,
                                       vaxdate_last_dose==vaxdate4_minint2_fix ~ final_vaxmfr4,
                                       vaxdate_last_dose==vaxdate5_minint2_fix ~ final_vaxmfr5,
                                       vaxdate_last_dose==vaxdate6_minint2_fix ~ final_vaxmfr6,
                                       is.na(vaxdate_last_dose) ~ "check: unvax",
                                       TRUE ~ "Missing"))

# set the vaccine product based on the final dose - 
# this is currently set up to default to the CVX codes in the vaxtype variable
# for those missing the CVX code, if the date is before 9/1/22 can default to the provided manufacturer (monovalent)

concordantFinal <- concordantFinal %>%
  mutate(vax_prod_last_dose=case_when(is.na(vaxtype_last_dose)==F & vaxtype_last_dose %in% c("208", "217", "218", "219") ~ "Pfizer monovalent",
                                      is.na(vaxtype_last_dose)==F & vaxtype_last_dose %in% c("300","301","302") & vaxdate_last_dose >= as.Date("2022-09-01") ~ "Pfizer bivalent",
                                      is.na(vaxtype_last_dose)==F & vaxtype_last_dose %in% c("207", "221", "228") ~ "Moderna monovalent",
                                      is.na(vaxtype_last_dose)==F & vaxtype_last_dose %in% c("229","230") & vaxdate_last_dose >= as.Date("2022-09-01") ~ "Moderna bivalent",
                                      is.na(vaxtype_last_dose)==F & vaxtype_last_dose %in% c("212") ~ "Janssen",
                                      is.na(vaxtype_last_dose)==F & vaxtype_last_dose %in% c("211") ~ "Novavax",
                                      is.na(vaxtype_last_dose)==F & vaxtype_last_dose %in% c("999","213","OTH") ~ "Unknown",
                                      vaxtype_last_dose=="check: unvax" ~ "Unvax",
                                      is.na(vaxtype_last_dose)==F & vaxtype_last_dose!="Missing" ~ "Other/Non-FDA",
                                      vaxtype_last_dose=="Missing" & vaxdate_last_dose < as.Date("2022-09-01") & vaxmfr_last_dose=="1" ~ "Pfizer monovalent",
                                      vaxtype_last_dose=="Missing" & vaxdate_last_dose < as.Date("2022-09-01") & vaxmfr_last_dose=="2" ~ "Moderna monovalent",
                                      vaxtype_last_dose=="Missing" & vaxdate_last_dose < as.Date("2022-09-01") & vaxmfr_last_dose=="4" ~ "Janssen",
                                      vaxtype_last_dose=="Missing" & vaxdate_last_dose < as.Date("2022-09-01") & vaxmfr_last_dose=="9" ~ "Unknown",
                                      T ~ "check"))

# make a variable for first bivalent dose received?? - this will help for defining the bivalent booster period for people who end up getting more than one dose of the bivalent booster (thinking way ahead)
# not sure if we will actually need this.. at first I thought it would be useful, but I'm not really thinking of a use case for it
concordantFinal <- concordantFinal %>%
  mutate(first_bivalent_dose = case_when(is.na(vaxdate1_minint2_fix)==F & vaxdate1_minint2_fix >= as.Date("2022-09-01") & final_vaxtype1 %in% c("229","300","301","230","302") ~ vaxdate1_minint2_fix,
                                                is.na(vaxdate2_minint2_fix)==F & vaxdate2_minint2_fix >= as.Date("2022-09-01") & final_vaxtype2 %in% c("229","300","301","230","302") ~ vaxdate2_minint2_fix,
                                                is.na(vaxdate3_minint2_fix)==F & vaxdate3_minint2_fix >= as.Date("2022-09-01") & final_vaxtype3 %in% c("229","300","301","230","302") ~ vaxdate3_minint2_fix,
                                                is.na(vaxdate4_minint2_fix)==F & vaxdate4_minint2_fix >= as.Date("2022-09-01") & final_vaxtype4 %in% c("229","300","301","230","302") ~ vaxdate4_minint2_fix,
                                                is.na(vaxdate5_minint2_fix)==F & vaxdate5_minint2_fix >= as.Date("2022-09-01") & final_vaxtype5 %in% c("229","300","301","230","302") ~ vaxdate5_minint2_fix,
                                                is.na(vaxdate6_minint2_fix)==F & vaxdate6_minint2_fix >= as.Date("2022-09-01") & final_vaxtype6 %in% c("229","300","301","230","302") ~ vaxdate6_minint2_fix,
                                                TRUE ~ NA_Date_))

# make a variable for the time between the first bivalent dose and the prior dose received? 
concordantFinal <- concordantFinal %>%
  mutate(time_biv_prior_dose = case_when(is.na(first_bivalent_dose) ~ NA_real_,
                                       is.na(vaxdate1_minint2_fix)==F & first_bivalent_dose==vaxdate1_minint2_fix ~ NA_real_,
                                       is.na(vaxdate2_minint2_fix)==F & first_bivalent_dose==vaxdate2_minint2_fix ~ as.numeric((vaxdate2_minint2_fix - vaxdate1_minint2_fix)),
                                       is.na(vaxdate3_minint2_fix)==F & first_bivalent_dose==vaxdate3_minint2_fix ~ as.numeric((vaxdate3_minint2_fix - vaxdate2_minint2_fix)),
                                       is.na(vaxdate4_minint2_fix)==F & first_bivalent_dose==vaxdate4_minint2_fix ~ as.numeric((vaxdate4_minint2_fix - vaxdate3_minint2_fix)),
                                       is.na(vaxdate5_minint2_fix)==F & first_bivalent_dose==vaxdate5_minint2_fix ~ as.numeric((vaxdate5_minint2_fix - vaxdate4_minint2_fix)),
                                       is.na(vaxdate6_minint2_fix)==F & first_bivalent_dose==vaxdate6_minint2_fix ~ as.numeric((vaxdate6_minint2_fix - vaxdate5_minint2_fix)),
                                       TRUE ~ NA_real_))


# Use CVX codes from vax_prod_last_dose to assign vax status        
concordantFinal <- concordantFinal %>%
  mutate(vax_status_bivalent = case_when(vax_status == "Unvax" ~ "Unvax",
                                    vax_status == "Partial" ~ "Partial",
                                    vax_status_boost == "Fully" ~ "Vaccinated without booster",
                                    vax_status_boost == "Boosted" & vax_prod_last_dose %in% c("Pfizer bivalent","Moderna bivalent") ~ "Boosted with bivalent",
                                    vax_status_boost == "Boosted" & vax_prod_last_dose != "check" ~ "Boosted without bivalent",
                                    TRUE ~ "check"))

# add a variable to track how many we recode below
n_biv_firstround<-sum(concordantFinal$vax_status_bivalent=="Boosted with bivalent",na.rm=T)

# Check for the situation where bivalent doses may be put in the PS slots and reassign as boosted
# if there's a bivalent dose in slot 1 or 2 and the date is after 9/1/22, AND when pos spec date is at least 14 days after that dose AND the original first 2 doses weren't AZ
# NOTE: LEFT OFF CODE 302 FOR NOW, SEEMS TO BE NOT JUST A BOOSTER FORMULATION?

concordantFinal <- concordantFinal %>%
  mutate(vax_status_bivalent = case_when(vax_status_bivalent=="Boosted with bivalent" ~ vax_status_bivalent,
                                         final_vaxtype1 %in% c("229","300","301","230") & vaxdate1_minint2_fix >= as.Date("2022-09-01") & pos_test_date > (vaxdate1_minint2_fix + 14) & (vaxmfr1_rc!="5" & vaxmfr2_rc!="5") ~ "Boosted with bivalent",
                                         final_vaxtype2 %in% c("229","300","301","230") & vaxdate2_minint2_fix >= as.Date("2022-09-01") & pos_test_date > (vaxdate2_minint2_fix + 14) & (vaxmfr1_rc!="5" & vaxmfr2_rc!="5") ~ "Boosted with bivalent",
                                         T ~ vax_status_bivalent))

n_biv_PS_recode<-sum(concordantFinal$vax_status_bivalent=="Boosted with bivalent",na.rm=T)

# output in a table
vax_status_biv_table<-as.data.frame(addmargins(table(concordantFinal$vax_status_bivalent, concordantFinal$vax_prod_last_dose, useNA = "ifany")))
# replace the vax prod values with names
vax_status_biv_table$Var2<-as.character(vax_status_biv_table$Var2)

# rework the table structure from long to wide:
vax_status_biv_table<-pivot_wider(vax_status_biv_table,names_from="Var2",values_from="Freq")
names(vax_status_biv_table)[1]<-"Vax status"

kable(vax_status_biv_table,booktabs=T,align=c("l",rep("r",length(unique(concordantFinal$vax_prod_last_dose))+1))) %>%
  kable_styling(full_width = F, position="left") %>%
    row_spec(as.numeric(row.names(vax_status_biv_table)[vax_status_biv_table$`Vax status` %in% c("Partial","Unvax")]),background="#ffeda0") %>% # color row yellow if will be removed
    column_spec(2:ncol(vax_status_biv_table),width=".8in") %>%
    column_spec(1,width="2.4in") %>%
  row_spec(nrow(vax_status_biv_table),bold=T)

```

$~$
Number of records with bivalent doses in the primary series that were recoded to be "boosted with bivalent": `r n_biv_PS_recode - n_biv_firstround`

## Time since vaccination determination

```{r time_since_vax}

# all categories: 2-<4 weeks; 2-<8 weeks; 2 weeks - <3 months; 4 weeks - <3 months; 8 weeks - <3 months;3-<6 months; 6-<12 months; 12+ months
# for categorical variables, need to make sure it's split into mutually exclusive categories
concordantFinal <- concordantFinal %>%
  mutate(time_since_last_dose = pos_test_date - vaxdate_last_dose,
         time_since_last_dose_cat = case_when(time_since_last_dose >= 14 & time_since_last_dose < 90 ~ "2 weeks-<3 months",
                                              time_since_last_dose >= 90 & time_since_last_dose < 180 ~ "3-<6 months",
                                              time_since_last_dose >= 180 & time_since_last_dose < 270 ~ "6-<9 months",
                                              time_since_last_dose >= 270 & time_since_last_dose < 365 ~ "9-<12 months",
                                              time_since_last_dose >= 365 ~ "12+ months",
                                              TRUE ~ "check"),
         time_since_last_dose_MMWR_case = case_when(time_since_last_dose >= 14 & time_since_last_dose < 56 ~ "2-<8 weeks",
                                              time_since_last_dose >= 56 & time_since_last_dose < 90 ~ "8 weeks-<3 months",
                                              time_since_last_dose >= 90 & time_since_last_dose < 180 ~ "3-<6 months",
                                              time_since_last_dose >= 180 & time_since_last_dose < 270 ~ "6-<9 months",
                                              time_since_last_dose >= 270 & time_since_last_dose < 365 ~ "9-<12 months",
                                              time_since_last_dose >= 365 ~ "12+ months",
                                              TRUE ~ "check"),
         time_since_last_dose_MMWR_deaths = case_when(time_since_last_dose >= 14 & time_since_last_dose < 28 ~ "2-<4 weeks",
                                              time_since_last_dose >= 28 & time_since_last_dose < 90 ~ "4 weeks-<3 months",
                                              time_since_last_dose >= 90 & time_since_last_dose < 180 ~ "3-<6 months",
                                              time_since_last_dose >= 180 & time_since_last_dose < 270 ~ "6-<9 months",
                                              time_since_last_dose >= 270 & time_since_last_dose < 365 ~ "9-<12 months",
                                              time_since_last_dose >= 365 ~ "12+ months",
                                              TRUE ~ "check"))



```


```{r time_since_vax_table, include=T, message=F, warning=F, echo=F}

time_since_vax_table <- concordantFinal %>%
  group_by(vax_status_bivalent, time_since_last_dose_cat) %>%
  summarize(n=n()) %>%
  pivot_wider(names_from=time_since_last_dose_cat,values_from=n) %>%
  select(vax_status_bivalent,"2 weeks-<3 months", "3-<6 months","6-<9 months","9-<12 months","12+ months")

time_since_vax_table[is.na(time_since_vax_table)]<-0

kable(time_since_vax_table) %>%
  kable_styling(full_width = F, position="left")
```


## QC some of the new CVX data

How much of each vaxtype variable (CVX codes) is missing among doses that have a vax date reported?

```{r include=T}
# How much of each dose vaxtype is missing for the ones that do have a vaxdate?
missing_vaxtype_table <- concordantFinal %>%
  summarize(vaxtype1 = paste0(sum((is.na(final_vaxtype1) | final_vaxtype1=="Missing") & is.na(vaxdate1_minint2_fix)==F)," (", round((sum(is.na(final_vaxtype1) & is.na(vaxdate1_minint2_fix)==F)/sum(is.na(vaxdate1_minint2_fix)==F))*100,1),"%)"),
            vaxtype2 = paste0(sum((is.na(final_vaxtype2) | final_vaxtype2=="Missing") & is.na(vaxdate2_minint2_fix)==F)," (", round((sum(is.na(final_vaxtype2) & is.na(vaxdate2_minint2_fix)==F)/sum(is.na(vaxdate2_minint2_fix)==F))*100,1),"%)"),
            vaxtype3 = paste0(sum((is.na(final_vaxtype3) | final_vaxtype3=="Missing") & is.na(vaxdate3_minint2_fix)==F)," (", round((sum(is.na(final_vaxtype3) & is.na(vaxdate3_minint2_fix)==F)/sum(is.na(vaxdate3_minint2_fix)==F))*100,1),"%)"),
            vaxtype4 = paste0(sum((is.na(final_vaxtype4) | final_vaxtype4=="Missing") & is.na(vaxdate4_minint2_fix)==F)," (", round((sum(is.na(final_vaxtype4) & is.na(vaxdate4_minint2_fix)==F)/sum(is.na(vaxdate4_minint2_fix)==F))*100,1),"%)"),
            vaxtype5 = paste0(sum((is.na(final_vaxtype5) | final_vaxtype5=="Missing") & is.na(vaxdate5_minint2_fix)==F)," (", round((sum(is.na(final_vaxtype5) & is.na(vaxdate5_minint2_fix)==F)/sum(is.na(vaxdate5_minint2_fix)==F))*100,1),"%)"),
            vaxtype6 = paste0(sum((is.na(final_vaxtype6) | final_vaxtype6=="Missing") & is.na(vaxdate6_minint2_fix)==F)," (", round((sum(is.na(final_vaxtype6) & is.na(vaxdate6_minint2_fix)==F)/sum(is.na(vaxdate6_minint2_fix)==F))*100,1),"%)"),
            last_dose=paste0(sum((is.na(vaxtype_last_dose) | vaxtype_last_dose=="Missing") & is.na(vaxdate_last_dose)==F)," (",round((sum((is.na(vaxtype_last_dose) | vaxtype_last_dose=="Missing") & is.na(vaxdate_last_dose)==F)/sum(is.na(vaxdate_last_dose)==F))*100,1),"%)"))


# Add yellow background to any cells that are missing 5%+?
if(str_match(missing_vaxtype_table$vaxtype1,"\\((.*?)%")[,2]!= "NaN" & as.numeric(str_match(missing_vaxtype_table$vaxtype1,"\\((.*?)%")[,2])>=5 ){
  missing_vaxtype_table$vaxtype1<-cell_spec(missing_vaxtype_table$vaxtype1,background="#ffeda0",format="html")
}
if(str_match(missing_vaxtype_table$vaxtype2,"\\((.*?)%")[,2]!= "NaN" & as.numeric(str_match(missing_vaxtype_table$vaxtype2,"\\((.*?)%")[,2])>=5 ){
  missing_vaxtype_table$vaxtype2<-cell_spec(missing_vaxtype_table$vaxtype2,background="#ffeda0",format="html")
}
if(str_match(missing_vaxtype_table$vaxtype3,"\\((.*?)%")[,2]!= "NaN" &as.numeric(str_match(missing_vaxtype_table$vaxtype3,"\\((.*?)%")[,2])>=5 ){
  missing_vaxtype_table$vaxtype3<-cell_spec(missing_vaxtype_table$vaxtype3,background="#ffeda0",format="html")
}
if(str_match(missing_vaxtype_table$vaxtype4,"\\((.*?)%")[,2]!= "NaN" &as.numeric(str_match(missing_vaxtype_table$vaxtype4,"\\((.*?)%")[,2])>=5 ){
  missing_vaxtype_table$vaxtype4<-cell_spec(missing_vaxtype_table$vaxtype4,background="#ffeda0",format="html")
}
if(str_match(missing_vaxtype_table$vaxtype5,"\\((.*?)%")[,2]!= "NaN" &as.numeric(str_match(missing_vaxtype_table$vaxtype5,"\\((.*?)%")[,2])>=5 ){
  missing_vaxtype_table$vaxtype5<-cell_spec(missing_vaxtype_table$vaxtype5,background="#ffeda0",format="html")
}
if(str_match(missing_vaxtype_table$vaxtype6,"\\((.*?)%")[,2]!= "NaN" & as.numeric(str_match(missing_vaxtype_table$vaxtype6,"\\((.*?)%")[,2])>=5 ){
  missing_vaxtype_table$vaxtype6<-cell_spec(missing_vaxtype_table$vaxtype6,background="#ffeda0",format="html")
}

if(str_match(missing_vaxtype_table$last_dose,"\\((.*?)%")[,2]!= "NaN" & as.numeric(str_match(missing_vaxtype_table$last_dose,"\\((.*?)%")[,2])>=5 ){
  missing_vaxtype_table$last_dose<-cell_spec(missing_vaxtype_table$last_dose,background="#ffeda0",format="html")
}


kable(missing_vaxtype_table,escape=F, align=c(rep("c",7))) %>%
  kable_styling(full_width = F, position="left")

```

$~$

How much of each vaxtype variable (CVX codes) is missing among doses that have a vax date reported, after 9/1/22?

```{r include=T}
# How much of each dose vaxtype is missing for the ones that do have a vaxdate?
missing_vaxtype_table_sep1 <- concordantFinal %>%
  summarize(vaxtype1 = paste0(sum((is.na(final_vaxtype1) | final_vaxtype1=="Missing") & is.na(vaxdate1_minint2_fix)==F & vaxdate1_minint2_fix>=as.Date("2022-09-01"))," (", round((sum(is.na(final_vaxtype1) & is.na(vaxdate1_minint2_fix)==F & vaxdate1_minint2_fix>=as.Date("2022-09-01"))/sum(is.na(vaxdate1_minint2_fix)==F & vaxdate1_minint2_fix>=as.Date("2022-09-01")))*100,1),"%)"),
            vaxtype2 = paste0(sum((is.na(final_vaxtype2) | final_vaxtype2=="Missing") & is.na(vaxdate2_minint2_fix)==F & vaxdate2_minint2_fix>=as.Date("2022-09-01"))," (", round((sum(is.na(final_vaxtype2) & is.na(vaxdate2_minint2_fix)==F & vaxdate2_minint2_fix>=as.Date("2022-09-01"))/sum(is.na(vaxdate2_minint2_fix)==F & vaxdate2_minint2_fix>=as.Date("2022-09-01")))*100,1),"%)"),
            vaxtype3 = paste0(sum((is.na(final_vaxtype3) | final_vaxtype3=="Missing") & is.na(vaxdate3_minint2_fix)==F & vaxdate3_minint2_fix>=as.Date("2022-09-01"))," (", round((sum(is.na(final_vaxtype3) & is.na(vaxdate3_minint2_fix)==F & vaxdate3_minint2_fix>=as.Date("2022-09-01"))/sum(is.na(vaxdate3_minint2_fix)==F & vaxdate3_minint2_fix>=as.Date("2022-09-01")))*100,1),"%)"),
            vaxtype4 = paste0(sum((is.na(final_vaxtype4) | final_vaxtype4=="Missing") & is.na(vaxdate4_minint2_fix)==F & vaxdate4_minint2_fix>=as.Date("2022-09-01"))," (", round((sum(is.na(final_vaxtype4) & is.na(vaxdate4_minint2_fix)==F & vaxdate4_minint2_fix>=as.Date("2022-09-01"))/sum(is.na(vaxdate4_minint2_fix)==F & vaxdate4_minint2_fix>=as.Date("2022-09-01")))*100,1),"%)"),
            vaxtype5 = paste0(sum((is.na(final_vaxtype5) | final_vaxtype5=="Missing") & is.na(vaxdate5_minint2_fix)==F & vaxdate5_minint2_fix>=as.Date("2022-09-01"))," (", round((sum(is.na(final_vaxtype5) & is.na(vaxdate5_minint2_fix)==F & vaxdate5_minint2_fix>=as.Date("2022-09-01"))/sum(is.na(vaxdate5_minint2_fix)==F & vaxdate5_minint2_fix>=as.Date("2022-09-01")))*100,1),"%)"),
            vaxtype6 = paste0(sum((is.na(final_vaxtype6) | final_vaxtype6=="Missing") & is.na(vaxdate6_minint2_fix)==F & vaxdate6_minint2_fix>=as.Date("2022-09-01"))," (", round((sum(is.na(final_vaxtype6) & is.na(vaxdate6_minint2_fix)==F & vaxdate6_minint2_fix>=as.Date("2022-09-01"))/sum(is.na(vaxdate6_minint2_fix)==F & vaxdate6_minint2_fix>=as.Date("2022-09-01")))*100,1),"%)"),
            last_dose=paste0(sum((is.na(vaxtype_last_dose) | vaxtype_last_dose=="Missing") & is.na(vaxdate_last_dose)==F & vaxdate_last_dose>=as.Date("2022-09-01"))," (",round((sum((is.na(vaxtype_last_dose) | vaxtype_last_dose=="Missing") & is.na(vaxdate_last_dose)==F & vaxdate_last_dose>=as.Date("2022-09-01"))/sum(is.na(vaxdate_last_dose)==F & vaxdate_last_dose>=as.Date("2022-09-01")))*100,1),"%)"))

# Add yellow background to any cells that are missing 5%+?
if(str_match(missing_vaxtype_table_sep1$vaxtype1,"\\((.*?)%")[,2]!= "NaN" & as.numeric(str_match(missing_vaxtype_table_sep1$vaxtype1,"\\((.*?)%")[,2])>=5 ){
  missing_vaxtype_table_sep1$vaxtype1<-cell_spec(missing_vaxtype_table_sep1$vaxtype1,background="#ffeda0",format="html")
}
if(str_match(missing_vaxtype_table_sep1$vaxtype2,"\\((.*?)%")[,2]!= "NaN" & as.numeric(str_match(missing_vaxtype_table_sep1$vaxtype2,"\\((.*?)%")[,2])>=5 ){
  missing_vaxtype_table_sep1$vaxtype2<-cell_spec(missing_vaxtype_table_sep1$vaxtype2,background="#ffeda0",format="html")
}
if(str_match(missing_vaxtype_table_sep1$vaxtype3,"\\((.*?)%")[,2]!= "NaN" &as.numeric(str_match(missing_vaxtype_table_sep1$vaxtype3,"\\((.*?)%")[,2])>=5 ){
  missing_vaxtype_table_sep1$vaxtype3<-cell_spec(missing_vaxtype_table_sep1$vaxtype3,background="#ffeda0",format="html")
}
if(str_match(missing_vaxtype_table_sep1$vaxtype4,"\\((.*?)%")[,2]!= "NaN" &as.numeric(str_match(missing_vaxtype_table_sep1$vaxtype4,"\\((.*?)%")[,2])>=5 ){
  missing_vaxtype_table_sep1$vaxtype4<-cell_spec(missing_vaxtype_table_sep1$vaxtype4,background="#ffeda0",format="html")
}
if(str_match(missing_vaxtype_table_sep1$vaxtype5,"\\((.*?)%")[,2]!= "NaN" &as.numeric(str_match(missing_vaxtype_table_sep1$vaxtype5,"\\((.*?)%")[,2])>=5 ){
  missing_vaxtype_table_sep1$vaxtype5<-cell_spec(missing_vaxtype_table_sep1$vaxtype5,background="#ffeda0",format="html")
}
if(str_match(missing_vaxtype_table_sep1$vaxtype6,"\\((.*?)%")[,2]!= "NaN" & as.numeric(str_match(missing_vaxtype_table_sep1$vaxtype6,"\\((.*?)%")[,2])>=5 ){
  missing_vaxtype_table_sep1$vaxtype6<-cell_spec(missing_vaxtype_table_sep1$vaxtype6,background="#ffeda0",format="html")
}

if(str_match(missing_vaxtype_table_sep1$last_dose,"\\((.*?)%")[,2]!= "NaN" & as.numeric(str_match(missing_vaxtype_table_sep1$last_dose,"\\((.*?)%")[,2])>=5 ){
  missing_vaxtype_table_sep1$last_dose<-cell_spec(missing_vaxtype_table_sep1$last_dose,background="#ffeda0",format="html")
}


kable(missing_vaxtype_table_sep1, escape=F,align=c(rep("c",7))) %>%
  kable_styling(full_width = F, position="left")

```


$~$

How many doses have a particular CVX code entered for the vaxtype but have a non-matching manufacturer value?

```{r include=T}
# How many have 213 or 999 for the vaxtype but have a known mfr?
vaxtype_unknown_table <- concordantFinal %>%
  summarize(Dose1 = sum(is.na(final_vaxtype1)==F & final_vaxtype1 %in% c("213","999") & is.na(final_vaxmfr1)==F & final_vaxmfr1 != "9"),
            Dose2 = sum(is.na(final_vaxtype2)==F & final_vaxtype2 %in% c("213","999") & is.na(final_vaxmfr2)==F & final_vaxmfr2 != "9" ),
            Dose3 = sum(is.na(final_vaxtype3)==F & final_vaxtype3 %in% c("213","999") & is.na(final_vaxmfr3)==F & final_vaxmfr3 != "9" ),
            Dose4 = sum(is.na(final_vaxtype4)==F & final_vaxtype4 %in% c("213","999") & is.na(final_vaxmfr4)==F & final_vaxmfr4 != "9" ),
            Dose5 = sum(is.na(final_vaxtype5)==F & final_vaxtype5 %in% c("213","999") & is.na(final_vaxmfr5)==F & final_vaxmfr5 != "9" ),
            Dose6 = sum(is.na(final_vaxtype6)==F & final_vaxtype6 %in% c("213","999") & is.na(final_vaxmfr6)==F & final_vaxmfr6 != "9" ),
            last_dose = sum(is.na(vaxtype_last_dose)==F & vaxtype_last_dose %in% c("213","999") & is.na(vaxmfr_last_dose)==F & vaxmfr_last_dose != "9" )) %>%
  mutate("CVX/Mfr"="213,999 / Unknown")

# do the same for other mfrs?
# how many have Janssen CVX code but non-Janssen mfr?
vaxtype_janssen_table <- concordantFinal %>%
  summarize(Dose1 = sum(is.na(final_vaxtype1)==F & final_vaxtype1 %in% c("212") & is.na(final_vaxmfr1)==F & final_vaxmfr1 != "4"),
            Dose2 = sum(is.na(final_vaxtype2)==F & final_vaxtype2 %in% c("212") & is.na(final_vaxmfr2)==F & final_vaxmfr2 != "4" ),
            Dose3 = sum(is.na(final_vaxtype3)==F & final_vaxtype3 %in% c("212") & is.na(final_vaxmfr3)==F & final_vaxmfr3 != "4" ),
            Dose4 = sum(is.na(final_vaxtype4)==F & final_vaxtype4 %in% c("212") & is.na(final_vaxmfr4)==F & final_vaxmfr4 != "4" ),
            Dose5 = sum(is.na(final_vaxtype5)==F & final_vaxtype5 %in% c("212") & is.na(final_vaxmfr5)==F & final_vaxmfr5 != "4" ),
            Dose6 = sum(is.na(final_vaxtype6)==F & final_vaxtype6 %in% c("212") & is.na(final_vaxmfr6)==F & final_vaxmfr6 != "4" ),
            last_dose = sum(is.na(vaxtype_last_dose)==F & vaxtype_last_dose %in% c("212") & is.na(vaxmfr_last_dose)==F & vaxmfr_last_dose != "4")) %>%
  mutate("CVX/Mfr"="212 / Janssen")

# how many have Pfizer CVX code but non-Pfizer mfr?
vaxtype_pfizer_table <- concordantFinal %>%
  summarize(Dose1 = sum(is.na(final_vaxtype1)==F & final_vaxtype1 %in% c("208","217","218","219","300","301","302") & is.na(final_vaxmfr1)==F & final_vaxmfr1 != "1"),
            Dose2 = sum(is.na(final_vaxtype2)==F & final_vaxtype2 %in% c("208","217","218","219","300","301","302") & is.na(final_vaxmfr2)==F & final_vaxmfr2 != "1" ),
            Dose3 = sum(is.na(final_vaxtype3)==F & final_vaxtype3 %in% c("208","217","218","219","300","301","302") & is.na(final_vaxmfr3)==F & final_vaxmfr3 != "1" ),
            Dose4 = sum(is.na(final_vaxtype4)==F & final_vaxtype4 %in% c("208","217","218","219","300","301","302") & is.na(final_vaxmfr4)==F & final_vaxmfr4 != "1" ),
            Dose5 = sum(is.na(final_vaxtype5)==F & final_vaxtype5 %in% c("208","217","218","219","300","301","302") & is.na(final_vaxmfr5)==F & final_vaxmfr5 != "1" ),
            Dose6 = sum(is.na(final_vaxtype6)==F & final_vaxtype6 %in% c("208","217","218","219","300","301","302") & is.na(final_vaxmfr6)==F & final_vaxmfr6 != "1" ),
            last_dose = sum(is.na(vaxtype_last_dose)==F & vaxtype_last_dose %in% c("208","217","218","219","300","301","302") & is.na(vaxmfr_last_dose)==F & vaxmfr_last_dose != "1")) %>%
  mutate("CVX/Mfr"="208,217,218,219,300,301,302 / Pfizer")

# how many have Moderna CVX code but non-Moderna mfr?
vaxtype_moderna_table <- concordantFinal %>%
  summarize(Dose1 = sum(is.na(final_vaxtype1)==F & final_vaxtype1 %in% c("207","221","228","229","230") & is.na(final_vaxmfr1)==F & final_vaxmfr1 != "2"),
            Dose2 = sum(is.na(final_vaxtype2)==F & final_vaxtype2 %in% c("207","221","228","229","230") & is.na(final_vaxmfr2)==F & final_vaxmfr2 != "2" ),
            Dose3 = sum(is.na(final_vaxtype3)==F & final_vaxtype3 %in% c("207","221","228","229","230") & is.na(final_vaxmfr3)==F & final_vaxmfr3 != "2" ),
            Dose4 = sum(is.na(final_vaxtype4)==F & final_vaxtype4 %in% c("207","221","228","229","230") & is.na(final_vaxmfr4)==F & final_vaxmfr4 != "2" ),
            Dose5 = sum(is.na(final_vaxtype5)==F & final_vaxtype5 %in% c("207","221","228","229","230") & is.na(final_vaxmfr5)==F & final_vaxmfr5 != "2" ),
            Dose6 = sum(is.na(final_vaxtype6)==F & final_vaxtype6 %in% c("207","221","228","229","230") & is.na(final_vaxmfr6)==F & final_vaxmfr6 != "2" ),
            last_dose = sum(is.na(vaxtype_last_dose)==F & vaxtype_last_dose %in% c("207","221","228","229","230") & is.na(vaxmfr_last_dose)==F & vaxmfr_last_dose != "2")) %>%
  mutate("CVX/Mfr"="207,221,228,229,230 / Moderna")

cvx_discrepant_table <- rbind(vaxtype_pfizer_table,vaxtype_moderna_table,vaxtype_janssen_table,vaxtype_unknown_table)

cvx_discrepant_table<-cvx_discrepant_table[,c(8,1:7)]

kable(cvx_discrepant_table,align=c("l",rep("c",7))) %>%
  column_spec(2:8,width=".6in")

```

$~$

For ages 12+: Are we seeing monovalent boosters entered after 9/1/22, or bivalent boosters before 9/1/22? 

```{r check_biv_age, include=T,warning=F,message=F}
concordantFinal$age_grp <- factor(concordantFinal$age_grp, levels=c("0.5-4","5-11","12-17","18-29","30-49","50-64","65-79","80+"))

check_biv_age_table<-concordantFinal %>%
  filter(!(age_grp %in% c("0.5-4","5-11"))) %>%
  group_by(age_grp) %>%
  summarize(mono_boost_after_sep1=sum(is.na(vaxtype_last_dose)==F & vaxtype_last_dose %in% c("208","217","218","219","207", "221", "228") & vax_status_boost=="Boosted" & vaxdate_last_dose >= as.Date("2022-09-01")),
            biv_boost_pre_sep1=sum(is.na(vaxtype_last_dose)==F & vaxtype_last_dose %in% c("300","301","229","230","302") & vax_status_boost=="Boosted" & vaxdate_last_dose < as.Date("2022-09-01")))

names(check_biv_age_table)<-c("Age group","Monovalent final booster after 9/1/22","Bivalent final booster before 9/1/22")

kable(check_biv_age_table) %>%
  column_spec(1,width=".8in") %>%
  column_spec(2:3,"1.5in") 
```

$~$

For ages 5-11: Are we seeing monovalent boosters entered after 10/12/22, or bivalent boosters before 10/12/22? 

```{r check_biv_age2, include=T,warning=F,message=F}

check_biv_age_table2<-concordantFinal %>%
  filter(age_grp %in% c("5-11")) %>%
  group_by(age_grp) %>%
  summarize(mono_boost_after_oct12=sum(is.na(vaxtype_last_dose)==F & vaxtype_last_dose %in% c("208","217","218","219","207", "221", "228") & vax_status_boost=="Boosted" & vaxdate_last_dose >= as.Date("2022-10-12")),
            biv_boost_pre_oct12=sum(is.na(vaxtype_last_dose)==F & vaxtype_last_dose %in% c("300","301","229","230","302") & vax_status_boost=="Boosted" & vaxdate_last_dose < as.Date("2022-10-12")))

names(check_biv_age_table2)<-c("Age group","Monovalent final booster after 10/12/22","Bivalent final booster before 10/12/22")

kable(check_biv_age_table2) %>%
  column_spec(1,width=".8in") %>%
  column_spec(2:3,"1.5in") 
```

$~$

What is the distribution of the time between the bivalent booster and the preceding dose? How many were less than 56 days following the preceding dose?

```{r include=T}
summary(concordantFinal$time_biv_prior_dose)

biv_gap_under56_total<-sum(concordantFinal$time_biv_prior_dose<56,na.rm = T)
perc_biv_gap_under56_total<-round((sum(concordantFinal$time_biv_prior_dose<56,na.rm = T)/sum(is.na(concordantFinal$time_biv_prior_dose)==F))*100,2)

biv_gap_under56<-sum(concordantFinal$time_biv_prior_dose<56 & concordantFinal$vax_status_bivalent=="Boosted with bivalent",na.rm = T)
```

$~$
For all bivalent doses we have information on, how many were <56 days after the prior dose: `r biv_gap_under56_total` (`r perc_biv_gap_under56_total`\%)

$~$

For bivalent doses in people who are post-bivalent booster cases, how many were <56 days after the prior dose: `r biv_gap_under56`

$~$

What is the distribution of CVX codes for each vaccine dose by age group? Are we seeing <span style="background-color: #ffeda0;">adult formulations in the pediatric age groups</span>? Are we seeing any <span style="background-color: #fcbba1;">bivalent cvx codes in the primary series doses</span>? 

**Dose 1:**

```{r dose1_cvx_age_table, include=T,warning=F,message=F}
# Add a table(s) for checking the CVX codes by age group (for vaxtype 1-5?? or just final dose?) - are we seeing pediatric formulations entered for the correct age groups?

dose1_cvx_age_table<-concordantFinal %>%
  group_by(age_grp,final_vaxtype1) %>%
  summarize(n=n()) %>%
  pivot_wider(names_from=age_grp,values_from = n) %>%
  filter(is.na(final_vaxtype1)==F)

# convert all columns to character type
dose1_cvx_age_table[] <- lapply(dose1_cvx_age_table, as.character)

# Add yellow background to any cells for 0.5-4 that aren't the correct pediatric formulation
dose1_cvx_age_table$`0.5-4`[is.na(dose1_cvx_age_table$`0.5-4`)==F & !(dose1_cvx_age_table$final_vaxtype1 %in% c("219","228","230","302"))]<-cell_spec(dose1_cvx_age_table$`0.5-4`[is.na(dose1_cvx_age_table$`0.5-4`)==F & !(dose1_cvx_age_table$final_vaxtype1 %in% c("219","228","230","302"))], background="#ffeda0",format="html")

# Add yellow background to any cells for 5-11 that aren't the correct pediatric formulation
dose1_cvx_age_table$`5-11`[is.na(dose1_cvx_age_table$`5-11`)==F & !(dose1_cvx_age_table$final_vaxtype1 %in% c("218","228","221","227","301","229","230"))]<-cell_spec(dose1_cvx_age_table$`5-11`[is.na(dose1_cvx_age_table$`5-11`)==F & !(dose1_cvx_age_table$final_vaxtype1 %in% c("218","228","221","227","301","229","230"))], background="#ffeda0",format="html")

# add red background to any cells for any age group that received a bivalent dose for dose 1
for(i in 1:nrow(dose1_cvx_age_table)){
  for(j in 2:9){
    dose1_cvx_age_table[i,j]=ifelse(is.na(dose1_cvx_age_table[i,j])==F & dose1_cvx_age_table$final_vaxtype1[i] %in% c("229","300","301","230") & substr(dose1_cvx_age_table[i,j],1,1) != "<", cell_spec(dose1_cvx_age_table[i,j],background="#fcbba1",format="html"),
                                    ifelse(is.na(dose1_cvx_age_table[i,j])==F & dose1_cvx_age_table$final_vaxtype1[i] %in% c("229","300","301","230") & substr(dose1_cvx_age_table[i,j],1,1) == "<", gsub("#ffeda0","#fcbba1",dose1_cvx_age_table[i,j]),
                                    dose1_cvx_age_table[i,j]))
  }
}


# replace cvx code values with more descriptive text
dose1_cvx_age_table$final_vaxtype1[dose1_cvx_age_table$final_vaxtype1=="207"]<-"207 (Moderna, 18+)"
dose1_cvx_age_table$final_vaxtype1[dose1_cvx_age_table$final_vaxtype1=="208"]<-"208 (Pfizer, 12+)"
dose1_cvx_age_table$final_vaxtype1[dose1_cvx_age_table$final_vaxtype1=="228"]<-"228 (Moderna, 0.5-5 & IC)"
dose1_cvx_age_table$final_vaxtype1[dose1_cvx_age_table$final_vaxtype1=="212"]<-"212 (Janssen)"
dose1_cvx_age_table$final_vaxtype1[dose1_cvx_age_table$final_vaxtype1=="213"]<-"213 (Unknown COVID-19)"
dose1_cvx_age_table$final_vaxtype1[dose1_cvx_age_table$final_vaxtype1=="217"]<-"217 (Pfizer, 12+)"
dose1_cvx_age_table$final_vaxtype1[dose1_cvx_age_table$final_vaxtype1=="218"]<-"218 (Pfizer, 5-11)"
dose1_cvx_age_table$final_vaxtype1[dose1_cvx_age_table$final_vaxtype1=="219"]<-"219 (Pfizer, 0.5-4)"
dose1_cvx_age_table$final_vaxtype1[dose1_cvx_age_table$final_vaxtype1=="211"]<-"211 (Novavax)"
dose1_cvx_age_table$final_vaxtype1[dose1_cvx_age_table$final_vaxtype1=="229"]<-"229 (Moderna, bivalent, 6+)"
dose1_cvx_age_table$final_vaxtype1[dose1_cvx_age_table$final_vaxtype1=="301"]<-"301 (Pfizer, bivalent 5-11)"
dose1_cvx_age_table$final_vaxtype1[dose1_cvx_age_table$final_vaxtype1=="300"]<-"300 (Pfizer, bivalent 12+)"
dose1_cvx_age_table$final_vaxtype1[dose1_cvx_age_table$final_vaxtype1=="221"]<-"221 (Moderna, 6-11 or old booster)"
dose1_cvx_age_table$final_vaxtype1[dose1_cvx_age_table$final_vaxtype1=="210"]<-"210 (AstraZeneca)"
dose1_cvx_age_table$final_vaxtype1[dose1_cvx_age_table$final_vaxtype1=="230"]<-"230 (Moderna, bivalent 0.5-6)"
dose1_cvx_age_table$final_vaxtype1[dose1_cvx_age_table$final_vaxtype1=="302"]<-"302 (Pfizer, bivalent 0.5-4)"




# replace NAs with 0s
dose1_cvx_age_table<- dose1_cvx_age_table %>%
  mutate(across(everything(), as.character))
dose1_cvx_age_table[is.na(dose1_cvx_age_table)]<-"0"

# output as formatted table
kable(dose1_cvx_age_table, escape=F, align=c("l",rep("r",8))) %>%
  kable_styling(full_width = F,position="left")

```

$~$

**Dose 2 (REMOVING RECORDS WITH JANSSEN AS FIRST DOSE TO CHECK BIVALENT in PS ONLY):**

```{r dose2_cvx_age_table, include=T,warning=F,message=F}

dose2_cvx_age_table<-concordantFinal %>%
  filter(final_vaxmfr1!="4") %>%
  group_by(age_grp,final_vaxtype2) %>%
  summarize(n=n()) %>%
  pivot_wider(names_from=age_grp,values_from = n) %>%
  filter(is.na(final_vaxtype2)==F)

# convert all columns to character type
dose2_cvx_age_table[] <- lapply(dose2_cvx_age_table, as.character)

# Add yellow background to any cells for 0.5-4 that aren't the correct pediatric formulation
dose2_cvx_age_table$`0.5-4`[is.na(dose2_cvx_age_table$`0.5-4`)==F & !(dose2_cvx_age_table$final_vaxtype2 %in% c("219","228","230","302"))]<-cell_spec(dose2_cvx_age_table$`0.5-4`[is.na(dose2_cvx_age_table$`0.5-4`)==F & !(dose2_cvx_age_table$final_vaxtype2 %in% c("219","228","230","302"))], background="#ffeda0",format="html")

# Add yellow background to any cells for 5-11 that aren't the correct pediatric formulation
dose2_cvx_age_table$`5-11`[is.na(dose2_cvx_age_table$`5-11`)==F & !(dose2_cvx_age_table$final_vaxtype2 %in% c("218","228","221","227","301","229","230"))]<-cell_spec(dose2_cvx_age_table$`5-11`[is.na(dose2_cvx_age_table$`5-11`)==F & !(dose2_cvx_age_table$final_vaxtype2 %in% c("218","228","221","227","301","229","230"))], background="#ffeda0",format="html")

# add red background to any cells for any age group that received a bivalent dose for dose 1
for(i in 1:nrow(dose2_cvx_age_table)){
  for(j in 2:9){
    dose2_cvx_age_table[i,j]=ifelse(is.na(dose2_cvx_age_table[i,j])==F & dose2_cvx_age_table$final_vaxtype2[i] %in% c("229","300","301","230") & substr(dose2_cvx_age_table[i,j],1,1) != "<", cell_spec(dose2_cvx_age_table[i,j],background="#fcbba1",format="html"),
                                    ifelse(is.na(dose2_cvx_age_table[i,j])==F & dose2_cvx_age_table$final_vaxtype2[i] %in% c("229","300","301","230") & substr(dose2_cvx_age_table[i,j],1,1) == "<", gsub("#ffeda0","#fcbba1",dose2_cvx_age_table[i,j]),
                                    dose2_cvx_age_table[i,j]))
  }
}

# replace cvx code values with more descriptive text
dose2_cvx_age_table$final_vaxtype2[dose2_cvx_age_table$final_vaxtype2=="207"]<-"207 (Moderna, 18+)"
dose2_cvx_age_table$final_vaxtype2[dose2_cvx_age_table$final_vaxtype2=="208"]<-"208 (Pfizer, 12+)"
dose2_cvx_age_table$final_vaxtype2[dose2_cvx_age_table$final_vaxtype2=="228"]<-"228 (Moderna, 0.5-5 & IC)"
dose2_cvx_age_table$final_vaxtype2[dose2_cvx_age_table$final_vaxtype2=="212"]<-"212 (Janssen)"
dose2_cvx_age_table$final_vaxtype2[dose2_cvx_age_table$final_vaxtype2=="213"]<-"213 (Unknown COVID-19)"
dose2_cvx_age_table$final_vaxtype2[dose2_cvx_age_table$final_vaxtype2=="217"]<-"217 (Pfizer, 12+)"
dose2_cvx_age_table$final_vaxtype2[dose2_cvx_age_table$final_vaxtype2=="218"]<-"218 (Pfizer, 5-11)"
dose2_cvx_age_table$final_vaxtype2[dose2_cvx_age_table$final_vaxtype2=="219"]<-"219 (Pfizer, 0.5-4)"
dose2_cvx_age_table$final_vaxtype2[dose2_cvx_age_table$final_vaxtype2=="211"]<-"211 (Novavax)"
dose2_cvx_age_table$final_vaxtype2[dose2_cvx_age_table$final_vaxtype2=="229"]<-"229 (Moderna, bivalent, 6+)"
dose2_cvx_age_table$final_vaxtype2[dose2_cvx_age_table$final_vaxtype2=="301"]<-"301 (Pfizer, bivalent 5-11)"
dose2_cvx_age_table$final_vaxtype2[dose2_cvx_age_table$final_vaxtype2=="300"]<-"300 (Pfizer, bivalent 12+)"
dose2_cvx_age_table$final_vaxtype2[dose2_cvx_age_table$final_vaxtype2=="221"]<-"221 (Moderna, 6-11 or old booster)"
dose2_cvx_age_table$final_vaxtype2[dose2_cvx_age_table$final_vaxtype2=="210"]<-"210 (AstraZeneca)"
dose2_cvx_age_table$final_vaxtype2[dose2_cvx_age_table$final_vaxtype2=="230"]<-"230 (Moderna, bivalent 0.5-6)"
dose2_cvx_age_table$final_vaxtype2[dose2_cvx_age_table$final_vaxtype2=="302"]<-"302 (Pfizer, bivalent 0.5-4)"



# replace NAs with 0s
dose2_cvx_age_table<- dose2_cvx_age_table %>%
  mutate(across(everything(), as.character))
dose2_cvx_age_table[is.na(dose2_cvx_age_table)]<-"0"

# output as formatted table
kable(dose2_cvx_age_table, escape=F, align=c("l",rep("r",8))) %>%
  kable_styling(full_width = F,position="left")

```


$~$

**Dose 3:**

```{r dose3_cvx_age_table, include=T,warning=F,message=F}

dose3_cvx_age_table<-concordantFinal %>%
  group_by(age_grp,final_vaxtype3) %>%
  summarize(n=n()) %>%
  pivot_wider(names_from=age_grp,values_from = n) %>%
  filter(is.na(final_vaxtype3)==F)

# Add yellow background to any cells for 0.5-4 that aren't the correct pediatric formulation
dose3_cvx_age_table$`0.5-4`[is.na(dose3_cvx_age_table$`0.5-4`)==F & !(dose3_cvx_age_table$final_vaxtype3 %in% c("219","228","230","302"))]<-cell_spec(dose3_cvx_age_table$`0.5-4`[is.na(dose3_cvx_age_table$`0.5-4`)==F & !(dose3_cvx_age_table$final_vaxtype3 %in% c("219","228","230","302"))], background="#ffeda0",format="html")

# Add yellow background to any cells for 5-11 that aren't the correct pediatric formulation
dose3_cvx_age_table$`5-11`[is.na(dose3_cvx_age_table$`5-11`)==F & !(dose3_cvx_age_table$final_vaxtype3 %in% c("218","228","221","227","301","229","230"))]<-cell_spec(dose3_cvx_age_table$`5-11`[is.na(dose3_cvx_age_table$`5-11`)==F & !(dose3_cvx_age_table$final_vaxtype3 %in% c("218","228","221","227","301","229","230"))], background="#ffeda0",format="html")


# replace cvx code values with more descriptive text
dose3_cvx_age_table$final_vaxtype3[dose3_cvx_age_table$final_vaxtype3=="207"]<-"207 (Moderna, 18+)"
dose3_cvx_age_table$final_vaxtype3[dose3_cvx_age_table$final_vaxtype3=="208"]<-"208 (Pfizer, 12+)"
dose3_cvx_age_table$final_vaxtype3[dose3_cvx_age_table$final_vaxtype3=="228"]<-"228 (Moderna, 0.5-5 & IC)"
dose3_cvx_age_table$final_vaxtype3[dose3_cvx_age_table$final_vaxtype3=="212"]<-"212 (Janssen)"
dose3_cvx_age_table$final_vaxtype3[dose3_cvx_age_table$final_vaxtype3=="213"]<-"213 (Unknown COVID-19)"
dose3_cvx_age_table$final_vaxtype3[dose3_cvx_age_table$final_vaxtype3=="217"]<-"217 (Pfizer, 12+)"
dose3_cvx_age_table$final_vaxtype3[dose3_cvx_age_table$final_vaxtype3=="218"]<-"218 (Pfizer, 5-11)"
dose3_cvx_age_table$final_vaxtype3[dose3_cvx_age_table$final_vaxtype3=="219"]<-"219 (Pfizer, 0.5-4)"
dose3_cvx_age_table$final_vaxtype3[dose3_cvx_age_table$final_vaxtype3=="211"]<-"211 (Novavax)"
dose3_cvx_age_table$final_vaxtype3[dose3_cvx_age_table$final_vaxtype3=="229"]<-"229 (Moderna, bivalent 6+)"
dose3_cvx_age_table$final_vaxtype3[dose3_cvx_age_table$final_vaxtype3=="301"]<-"301 (Pfizer, bivalent 5-11)"
dose3_cvx_age_table$final_vaxtype3[dose3_cvx_age_table$final_vaxtype3=="300"]<-"300 (Pfizer, bivalent 12+)"
dose3_cvx_age_table$final_vaxtype3[dose3_cvx_age_table$final_vaxtype3=="221"]<-"221 (Moderna, 6-11 or old booster)"
dose3_cvx_age_table$final_vaxtype3[dose3_cvx_age_table$final_vaxtype3=="210"]<-"210 (AstraZeneca)"
dose3_cvx_age_table$final_vaxtype3[dose3_cvx_age_table$final_vaxtype3=="230"]<-"230 (Moderna, bivalent 0.5-5)"
dose3_cvx_age_table$final_vaxtype3[dose3_cvx_age_table$final_vaxtype3=="302"]<-"302 (Pfizer, bivalent 0.5-4)"




# replace NAs with 0s
dose3_cvx_age_table<- dose3_cvx_age_table %>%
  mutate(across(everything(), as.character))
dose3_cvx_age_table[is.na(dose3_cvx_age_table)]<-"0"

# output as formatted table
kable(dose3_cvx_age_table, escape=F, align=c("l",rep("r",8))) %>%
  kable_styling(full_width = F,position="left")

```

$~$

**Dose 4:**

```{r dose4_cvx_age_table, include=T,warning=F,message=F}

dose4_cvx_age_table<-concordantFinal %>%
  group_by(age_grp,final_vaxtype4) %>%
  summarize(n=n()) %>%
  pivot_wider(names_from=age_grp,values_from = n) %>%
  filter(is.na(final_vaxtype4)==F)

# Add yellow background to any cells for 0.5-4 that aren't the correct pediatric formulation
dose4_cvx_age_table$`0.5-4`[is.na(dose4_cvx_age_table$`0.5-4`)==F & !(dose4_cvx_age_table$final_vaxtype4 %in% c("219","228","230","302"))]<-cell_spec(dose4_cvx_age_table$`0.5-4`[is.na(dose4_cvx_age_table$`0.5-4`)==F & !(dose4_cvx_age_table$final_vaxtype4 %in% c("219","228","230","302"))], background="#ffeda0",format="html")

# Add yellow background to any cells for 5-11 that aren't the correct pediatric formulation
dose4_cvx_age_table$`5-11`[is.na(dose4_cvx_age_table$`5-11`)==F & !(dose4_cvx_age_table$final_vaxtype4 %in% c("218","228","221","227","301","229","230"))]<-cell_spec(dose4_cvx_age_table$`5-11`[is.na(dose4_cvx_age_table$`5-11`)==F & !(dose4_cvx_age_table$final_vaxtype4 %in% c("218","228","221","227","301","229","230"))], background="#ffeda0",format="html")


# replace cvx code values with more descriptive text
dose4_cvx_age_table$final_vaxtype4[dose4_cvx_age_table$final_vaxtype4=="207"]<-"207 (Moderna, 18+)"
dose4_cvx_age_table$final_vaxtype4[dose4_cvx_age_table$final_vaxtype4=="208"]<-"208 (Pfizer, 12+)"
dose4_cvx_age_table$final_vaxtype4[dose4_cvx_age_table$final_vaxtype4=="228"]<-"228 (Moderna, 0.5-5 & IC)"
dose4_cvx_age_table$final_vaxtype4[dose4_cvx_age_table$final_vaxtype4=="212"]<-"212 (Janssen)"
dose4_cvx_age_table$final_vaxtype4[dose4_cvx_age_table$final_vaxtype4=="213"]<-"213 (Unknown COVID-19)"
dose4_cvx_age_table$final_vaxtype4[dose4_cvx_age_table$final_vaxtype4=="217"]<-"217 (Pfizer, 12+)"
dose4_cvx_age_table$final_vaxtype4[dose4_cvx_age_table$final_vaxtype4=="218"]<-"218 (Pfizer, 5-11)"
dose4_cvx_age_table$final_vaxtype4[dose4_cvx_age_table$final_vaxtype4=="219"]<-"219 (Pfizer, 0.5-4)"
dose4_cvx_age_table$final_vaxtype4[dose4_cvx_age_table$final_vaxtype4=="211"]<-"211 (Novavax)"
dose4_cvx_age_table$final_vaxtype4[dose4_cvx_age_table$final_vaxtype4=="229"]<-"229 (Moderna, bivalent, 6+)"
dose4_cvx_age_table$final_vaxtype4[dose4_cvx_age_table$final_vaxtype4=="301"]<-"301 (Pfizer, bivalent 5-11)"
dose4_cvx_age_table$final_vaxtype4[dose4_cvx_age_table$final_vaxtype4=="300"]<-"300 (Pfizer, bivalent 12+)"
dose4_cvx_age_table$final_vaxtype4[dose4_cvx_age_table$final_vaxtype4=="221"]<-"221 (Moderna, 6-11 or old booster)"
dose4_cvx_age_table$final_vaxtype4[dose4_cvx_age_table$final_vaxtype4=="210"]<-"210 (AstraZeneca)"
dose4_cvx_age_table$final_vaxtype4[dose4_cvx_age_table$final_vaxtype4=="230"]<-"230 (Moderna, bivalent 0.5-6)"
dose4_cvx_age_table$final_vaxtype4[dose4_cvx_age_table$final_vaxtype4=="302"]<-"302 (Pfizer, bivalent 0.5-4)"



# replace NAs with 0s
dose4_cvx_age_table<- dose4_cvx_age_table %>%
  mutate(across(everything(), as.character))
dose4_cvx_age_table[is.na(dose4_cvx_age_table)]<-"0"

# output as formatted table
kable(dose4_cvx_age_table, escape=F, align=c("l",rep("r",8))) %>%
  kable_styling(full_width = F,position="left")

```

```{r cvx_month_table}
# Add a table(s) for CVX codes recorded by month?
```


# Summary of Data Exclusions

```{r summary, include=T}
# LRL update: add a table at the end that summarizes all data excluded at the different checks to see this at a glance

# set variable for total n excluded
total_n_excluded<- n_exact_dups + pct_missing$n_na_pos_test_date + n_before_range + n_after_range + missing_dob$n_na_age + agewonky$n + nrow(too_young) + n_fillerDOB + nrow(discordant) + nrow(nonChron) + n_vax_history_exclude + n_vax_dates_exclude 

summary_table<-as.data.frame(rbind(c("Exact duplicate records", n_exact_dups, round((n_exact_dups/nrow(upload_data))*100,2)),
                     c("Missing specimen collection date", pct_missing$n_na_pos_test_date, round(pct_missing$pct_na_pos_test_date,2)),
                     c("Before requested date range",n_before_range,round((n_before_range/n_submitted)*100,2)),
                     c("After requested date range",n_after_range,round((n_after_range/n_submitted)*100,2)),
                     c("Missing DOB",missing_dob$n_na_age,round(missing_dob$pct_na_age,2)),
                     c("Age < 0",agewonky$n,round((agewonky$n/n_submitted)*100,2)),
                     c("Too young (<6 months)",nrow(too_young),round((nrow(too_young)/n_submitted)*100,2)),
                     c("Filler DOB",n_fillerDOB,round((n_fillerDOB/n_submitted)*100,2)),
                     c("Vaccine manufacturer but no date",nrow(discordant),round((nrow(discordant)/n_submitted)*100,2)),
                     c("Out of order vax dates",nrow(nonChron),round((nrow(nonChron)/n_submitted)*100,2)),
                     c("Not fully vax based on vax dose history",n_vax_history_exclude,round((n_vax_history_exclude/n_submitted)*100,2)),
                     c("Not fully vax based on vax dates",n_vax_dates_exclude,round((n_vax_dates_exclude/n_submitted)*100,2)),
                     c("Total",total_n_excluded,round((total_n_excluded/n_submitted)*100,2))))

names(summary_table)<-c("Data check","N records excluded",paste0("Percent of submitted data (N=",format(n_submitted,big.mark=","),") excluded"))

kable(summary_table,booktabs=T,align="lrr") %>%
  kable_styling(latex_options=c('striped'),full_width = F) %>%
  column_spec(1,width="2.5in") %>%
  column_spec(2,width="1.3in") %>%
  column_spec(3,width="1.7in") %>%
  row_spec(0, align = "c") %>% 
  row_spec(nrow(summary_table),color="white",background="gray")
  

```

Keep track of cases <5 at first vax dose, but who had turned 5 by the time they had covid (and who were technically fully vaccinated at that time):

```{r track_under_5s}
# add a quick one-liner to keep track of cases that started their vaccine series before turning 5 but turned 5 by the time they had covid

n_under5_vax1<-sum(concordantFinal$age_at_vaxdose1<5 & concordantFinal$age_calc>=5,na.rm=T)

```

Number of cases < 5 years old at first vaccine dose: `r n_under5_vax1`

# Export of Data

```{r freeze_data}

linelist <-
  concordantFinal %>%
  filter(vax_status == "Fully") %>%
  select(-c(vaxmfr1_rc, vaxmfr2_rc, vaxmfr3_rc, vaxmfr4_rc, vaxmfr5_rc,vaxmfr6_rc,
         dateSeq,mfrSeq,dose_agree,vaxdate1_dedup,vaxdate2_dedup,vaxdate3_dedup,vaxdate4_dedup,vaxdate5_dedup,vaxdate6_dedup,vaxmfr1_dedup,vaxmfr2_dedup,vaxmfr3_dedup,vaxmfr4_dedup,vaxmfr5_dedup,vaxmfr6_dedup, vaxdate_condense,vaxmfr_condense,
         vaxdate1_fix,vaxdate2_fix,vaxdate3_fix,vaxdate4_fix,vaxdate5_fix,vaxdate6_fix,vaxmfr1_fix,vaxmfr2_fix,vaxmfr3_fix,vaxmfr4_fix,vaxmfr5_fix,vaxmfr6_fix,vaxCourse_fix,dateSeq_fix,mfrSeq_fix,dose_agree_fix,vaxdate1_minint1,vaxmfr1_minint1,vaxdate2_minint1,vaxmfr2_minint1,vaxdate3_minint1,vaxmfr3_minint1,vaxdate4_minint1,vaxmfr4_minint1,vaxdate5_minint1,vaxmfr5_minint1,vaxdate6_minint1,vaxmfr6_minint1,vaxdate_minint1_condense,vaxmfr_minint1_condense,vaxdate1_minint1_fix,vaxdate2_minint1_fix,vaxdate3_minint1_fix,vaxdate4_minint1_fix,vaxdate5_minint1_fix,vaxdate6_minint1_fix,vaxmfr1_minint1_fix,vaxmfr2_minint1_fix,vaxmfr3_minint1_fix,vaxmfr4_minint1_fix,vaxmfr5_minint1_fix,vaxmfr6_minint1_fix,vaxCourse_minint1_fix,dateSeq_minint1_fix,mfrSeq_minint1_fix,dose_agree_minint1_fix,vaxdate1_minint2,vaxmfr1_minint2,vaxdate2_minint2,vaxmfr2_minint2,vaxdate3_minint2,vaxmfr3_minint2,vaxdate4_minint2,vaxmfr4_minint2,vaxdate5_minint2,vaxmfr5_minint2,vaxdate6_minint2,vaxmfr6_minint2,vaxdate_minint2_condense,vaxmfr_minint2_condense))


# Write out final linelist
fwrite(linelist, file = paste0(linelist_output_path, juris,"_", Sys.Date(), ".csv"), row.names = F)


```


Two products ultimately get exported: a full linelist of cases January 2021 onwards and aggregated files for VIBS reporting.

```{r aggregate}

### WILL NEED NEW AGG FILES OUTPUT ###
# One using just the new up-to-date terminology: unvax, partial, vax no booster, vax with bivalent boost, vax without biv boost
# And one including the time since vax categories - start by outputting all time categories?
combos_new <- expand.grid(
  age_grp = c("0.5-4","5-11", "12-17", "18-29", "30-49", "50-64", "65-79", "80+"),
  vaccine_product_recent = c("Pfizer monovalent","Pfizer bivalent","Moderna monovalent","Moderna bivalent","Janssen","Other/unknown (including Novavax)"),
  year_mmwr_wk = as.numeric(c(202140:202152, 202201:params$mmwr_wk_cases_end))) %>%
  mutate(age_grp = factor(age_grp, levels = c("0.5-4","5-11", "12-17", "18-29", "30-49", "50-64", "65-79", "80+"), ordered = T)
)

# make another version, essentially the same but output variable name for vax prod will say booster to match the templates
combos_new_boostprod <- expand.grid(
  age_grp = c("0.5-4","5-11", "12-17", "18-29", "30-49", "50-64", "65-79", "80+"),
  booster_product_recent = c("Pfizer monovalent","Pfizer bivalent","Moderna monovalent","Moderna bivalent","Janssen","Other/unknown (including Novavax)"),
  year_mmwr_wk = as.numeric(c(202140:202152, 202201:params$mmwr_wk_cases_end))) %>%
  mutate(age_grp = factor(age_grp, levels = c("0.5-4","5-11", "12-17", "18-29", "30-49", "50-64", "65-79", "80+"), ordered = T)
)

# we don't actually need these below
# combos_new_time <- expand.grid(
#   age_grp = c("0.5-4","5-11", "12-17", "18-29", "30-49", "50-64", "65-79", "80+"),
#   booster_product_recent = c("Pfizer monovalent","Pfizer bivalent","Moderna monovalent","Moderna bivalent","Janssen","Other/unknown (including Novavax)"),
#   year_mmwr_wk = as.numeric(c(202140:202152, 202201:params$mmwr_wk_cases_end)),
#   time_since_last_dose_cat = c("2 weeks-<3 months","3-<6 months","6-<9 months","9-<12 months","12+ months")) %>%
#   mutate(age_grp = factor(age_grp, levels = c("0.5-4","5-11", "12-17", "18-29", "30-49", "50-64", "65-79", "80+"), ordered = T)
# )
# 
# combos_new_time_mmwr <- expand.grid(
#   age_grp = c("0.5-4","5-11", "12-17", "18-29", "30-49", "50-64", "65-79", "80+"),
#   booster_product_recent = c("Pfizer monovalent","Pfizer bivalent","Moderna monovalent","Moderna bivalent","Janssen","Other/unknown (including Novavax)"),
#   year_mmwr_wk = as.numeric(c(202140:202152, 202201:params$mmwr_wk_cases_end)),
#   time_since_last_dose_cat = c("2-<8 weeks","8 weeks-<3 months","3-<6 months","6-<9 months","9-<12 months","12+ months")) %>%
#   mutate(age_grp = factor(age_grp, levels = c("0.5-4","5-11", "12-17", "18-29", "30-49", "50-64", "65-79", "80+"), ordered = T)
# )
# 
# combos_new_time_mmwr_deaths <- expand.grid(
#   age_grp = c("0.5-4","5-11", "12-17", "18-29", "30-49", "50-64", "65-79", "80+"),
#   booster_product_recent = c("Pfizer monovalent","Pfizer bivalent","Moderna monovalent","Moderna bivalent","Janssen","Other/unknown (including Novavax)"),
#   year_mmwr_wk = as.numeric(c(202140:202152, 202201:params$mmwr_wk_cases_end)),
#   time_since_last_dose_cat = c("2-<4 weeks","4 weeks-<3 months","3-<6 months","6-<9 months","9-<12 months","12+ months")) %>%
#   mutate(age_grp = factor(age_grp, levels = c("0.5-4","5-11", "12-17", "18-29", "30-49", "50-64", "65-79", "80+"), ordered = T)
# )
#---------------------------------------------------------------------------------------------------------------------
# Combine "unknown" "other" and "novavax" into one category in the LL for aggregation
linelist <- linelist %>%
  mutate(vaccine_product_recent=case_when(vax_prod_last_dose %in% c("Unknown","Other/Non-FDA","Novavax") ~ "Other/unknown (including Novavax)",
                                          T ~ vax_prod_last_dose),
         booster_product_recent=vaccine_product_recent)


if(booster_reporter=="Yes"){
  linelist$age_grp<-as.character(linelist$age_grp)
  
  cases<-linelist %>%
    filter(vax_prod_last_dose != "check") %>%
    group_by(year_mmwr_wk,vaccine_product_recent,age_grp) %>%
    summarize(vax_without_booster=sum(vax_status_boost=="Fully"),
              vax_with_booster=sum(vax_status_boost=="Boosted")) %>%
    full_join(combos_new) %>%
    arrange(year_mmwr_wk,vaccine_product_recent,age_grp)
  
  cases[is.na(cases)]<-0
  
  fwrite(cases, file=paste0(aggregate_output_path, juris, "_case_", params$submission_date, ".csv"))
  
  
  deaths<-linelist %>%
    filter(vax_prod_last_dose != "check") %>%
    filter(outcome == "2", death_related == "1") %>%
    group_by(year_mmwr_wk,vaccine_product_recent,age_grp) %>%
    summarize(vax_without_booster=sum(vax_status_boost=="Fully"),
              vax_with_booster=sum(vax_status_boost=="Boosted")) %>%
    full_join(combos_new) %>% 
    filter(year_mmwr_wk <= params$mmwr_wk_deaths_end) %>%
    arrange(year_mmwr_wk,vaccine_product_recent,age_grp)
  
  deaths[is.na(deaths)]<-0
  
  fwrite(deaths, file=paste0(aggregate_output_path, juris, "_deaths_", params$submission_date, ".csv"))
  
  # Generate the time since vax files: output all time categories for now. eventually won't need all the MMWR ones
  
  cases_time<-linelist %>%
    filter(vax_prod_last_dose != "check") %>%
    group_by(year_mmwr_wk,booster_product_recent,age_grp) %>%
    filter(vax_status_boost=="Boosted") %>%
    summarize("boosted_2_<4weeks"=sum(time_since_last_dose_MMWR_deaths=="2-<4 weeks",na.rm=T),
              "boosted_2_<8weeks"=sum(time_since_last_dose_MMWR_case=="2-<8 weeks",na.rm=T),
              "boosted_2weeks_<3months"=sum(time_since_last_dose_cat=="2 weeks-<3 months",na.rm=T),
              "boosted_4weeks_<3months"=sum(time_since_last_dose_MMWR_deaths=="4 weeks-<3 months",na.rm=T),
              "boosted_8weeks_<3months"=sum(time_since_last_dose_MMWR_case=="8 weeks-<3 months",na.rm=T),
              "boosted_3_<6months"=sum(time_since_last_dose_cat=="3-<6 months",na.rm=T),
              "boosted_6_<9months"=sum(time_since_last_dose_cat=="6-<9 months",na.rm=T),
              "boosted_9_<12months"=sum(time_since_last_dose_cat=="9-<12 months",na.rm=T),
              "boosted_12+months"=sum(time_since_last_dose_cat=="12+ months",na.rm=T)) %>%
    full_join(combos_new_boostprod) %>%
    arrange(year_mmwr_wk,booster_product_recent,age_grp)
  
  cases_time[is.na(cases_time)]<-0
  
  fwrite(cases_time, file=paste0(aggregate_output_path, juris, "_case_time_since_vax_", params$submission_date, ".csv"))

  
  deaths_time<-linelist %>%
    filter(vax_prod_last_dose != "check") %>%
    filter(outcome == "2", death_related == "1") %>%
    group_by(year_mmwr_wk,booster_product_recent,age_grp) %>%
    filter(vax_status_boost=="Boosted") %>%
    summarize("boosted_2_<4weeks"=sum(time_since_last_dose_MMWR_deaths=="2-<4 weeks",na.rm=T),
              "boosted_2_<8weeks"=sum(time_since_last_dose_MMWR_case=="2-<8 weeks",na.rm=T),
              "boosted_2weeks_<3months"=sum(time_since_last_dose_cat=="2 weeks-<3 months",na.rm=T),
              "boosted_4weeks_<3months"=sum(time_since_last_dose_MMWR_deaths=="4 weeks-<3 months",na.rm=T),
              "boosted_8weeks_<3months"=sum(time_since_last_dose_MMWR_case=="8 weeks-<3 months",na.rm=T),
              "boosted_3_<6months"=sum(time_since_last_dose_cat=="3-<6 months",na.rm=T),
              "boosted_6_<9months"=sum(time_since_last_dose_cat=="6-<9 months",na.rm=T),
              "boosted_9_<12months"=sum(time_since_last_dose_cat=="9-<12 months",na.rm=T),
              "boosted_12+months"=sum(time_since_last_dose_cat=="12+ months",na.rm=T)) %>%
    full_join(combos_new_boostprod) %>%
    filter(year_mmwr_wk <= params$mmwr_wk_deaths_end) %>%
    arrange(year_mmwr_wk,booster_product_recent,age_grp)
  
  deaths_time[is.na(deaths_time)]<-0
  
  fwrite(deaths_time, file=paste0(aggregate_output_path, juris, "_deaths_time_since_vax_", params$submission_date, ".csv"))

}

#---------------------------------------------------------------------------------------------------------------------

```


